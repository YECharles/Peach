/*
 * DO NOT EDIT THIS FILE!
 *
 * Parser generated by BisonGen on Wed Jan 11 15:39:25 2006.
 */

#include "Python.h"
#include "structmember.h"
#include "../src/common.h"

#define PROJECT_NAME "Ft.Xml.XPointer"
#define PARSER_NAME "XPointerParser"
#define MODULE_INITFUNC initXPointerParserc

/* modules required for action routines */
static PyObject *XPointer;

/* token definitions */
#define NCName 257
#define QName 258
#define NormalChar 259
#define EscapedChar 260
#define StringWithoutParens 261

/* vector mapping lexer token numbers into internal token numbers */
static const int token_translations[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 8, 9, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 1, 3, 4, 5, 6, 7};

#define YYTRANSLATE(x) ((unsigned)(x) <= 261 ? token_translations[x] : 18)

/* vector of items of all rules. */
static const int rhs_tokens[] = {0, 11, 0, 12, 0, 3, 0, 13, 0, 12, 13, 0, 
14, 8, 15, 9, 0, 3, 0, 4, 0, 0, 16, 0, 17, 0, 16, 17, 0, 5, 0, 6, 0, 8, 
15, 9, 0};

/* vector of line numbers and filename of all rules */
static const char* const rule_info[] = {
    ": line 0",
    "Ft/Xml/XPointer/XPointer.bgen: line 21",
    "Ft/Xml/XPointer/XPointer.bgen: line 30",
    "Ft/Xml/XPointer/XPointer.bgen: line 44",
    "Ft/Xml/XPointer/XPointer.bgen: line 52",
    "Ft/Xml/XPointer/XPointer.bgen: line 63",
    "Ft/Xml/XPointer/XPointer.bgen: line 81",
    "Ft/Xml/XPointer/XPointer.bgen: line 100",
    "Ft/Xml/XPointer/XPointer.bgen: line 112",
    "Ft/Xml/XPointer/XPointer.bgen: line 129",
    "Ft/Xml/XPointer/XPointer.bgen: line 137",
    "Ft/Xml/XPointer/XPointer.bgen: line 153",
    "Ft/Xml/XPointer/XPointer.bgen: line 166",
    "Ft/Xml/XPointer/XPointer.bgen: line 186",
    "Ft/Xml/XPointer/XPointer.bgen: line 189",
    "Ft/Xml/XPointer/XPointer.bgen: line 198",
};

/* vector of string-names indexed by token number */
static const char* const token_names[] = {
    "<EOF>",
    "error",
    "$undefined.",
    "NCName",
    "QName",
    "NormalChar",
    "EscapedChar",
    "StringWithoutParens",
    "(",
    ")",
    "XPointer",
    "Shorthand",
    "SchemeBased",
    "PointerPart",
    "SchemeName",
    "SchemeData",
    "EscapedDataList",
    "EscapedData",
    "0",
};

/* symbol number of symbol that rule derives. */
static const int derives[] = {0, 10, 10, 11, 12, 12, 13, 14, 14, 15, 15, 
16, 16, 17, 17, 17};

/* number of symbols composing right hand side of rule. */
static const int rhs_size[] = {0, 1, 1, 1, 1, 2, 4, 1, 1, 0, 1, 1, 2, 1, 
1, 3};

/* default rule to reduce with in state. 0 means the default is an error.
   indexed by state number */
static const int default_action[] = {0, 3, 8, 1, 2, 4, 0, 7, 5, 9, 13, 14, 
9, 0, 10, 11, 0, 6, 12, 15, 0, 0, 0};

/* default state to go to after a reduction of a rule.
   indexed by variable number (lhs token) */
static const int default_goto[] = {20, 3, 4, 5, 6, 13, 14, 15};

/* index in yytable of the portion describing state (indexed by state number)
   If the value in yytable is positive, we shift the token and go to that state.
   If the value is negative, it is minus a rule number to reduce by.
   If the value is zero, the default action from yydefact[s] is used. */
static const int action_idx[] = {1, -6, -32768, -32768, 3, -32768, 0, -32768, 
-32768, -5, -32768, -32768, -5, 2, -5, -32768, 4, -32768, -32768, -32768, 
9, 10, -32768};

/* The index in yytable of the portion describing what to do after reducing a rule.
   The value from yytable is the state to go to. */
static const int goto_idx[] = {-32768, -32768, -32768, 8, -32768, 5, -32768, 
6};

/* A vector filled with portions for different uses.
   (using action_idx and goto_idx) */
static const int yytable[] = {10, 11, -7, 12, 1, 2, 7, 2, 9, 21, 22, 17, 
8, 19, 0, 0, 0, 16, 0, 0, 18};

/* a vector indexed in parallel with yytable.
   It indicates the bounds of the portion you are trying to examine. */
static const int yycheck[] = {5, 6, 8, 8, 3, 4, 3, 4, 8, 0, 0, 9, 4, 9, -1, 
-1, -1, 12, -1, -1, 14};

#define YYLAST 20
#define YYFINAL 22
#define YYFLAG -32768
#define YYNTBASE 10

#define LEXER_OP_FAILURE 0
#define LEXER_OP_SUCCESS 1
#define LEXER_OP_BOL 2
#define LEXER_OP_EOL 3
#define LEXER_OP_EOF 4
#define LEXER_OP_ANY 5
#define LEXER_OP_LITERAL 6
#define LEXER_OP_NOT_LITERAL 7
#define LEXER_OP_CHARSET 8
#define LEXER_OP_NOT_CHARSET 9
#define LEXER_OP_ASSERT 10
#define LEXER_OP_BRANCH 11
#define LEXER_OP_REPEAT 12
#define LEXER_OP_REPEAT_RANGE 13

#define LEXER_CHARSET_FAILURE 0
#define LEXER_CHARSET_LITERAL 1
#define LEXER_CHARSET_RANGE 2
#define LEXER_CHARSET_SMALL 3
#define LEXER_CHARSET_BIG 4

#define LEXER_INITIAL 1
#define LEXER_SCHEME_DATA 2
#define LEXER_START_STATE LEXER_INITIAL

static unsigned char lexer_charsets[55][32] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07,
    0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x7F, 0xFE, 0xFD, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x0F, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x31, 0xFC },
  { 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xF8,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
    0xFF, 0x7F, 0x7F, 0x54, 0xFD, 0xFF, 0x0F, 0x00 },
  { 0xFE, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xDF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x9F, 0x19, 0xFF, 0xFF, 0xFF, 0xCF, 0x3F, 0x03 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02,
    0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x07, 0x07, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0x07, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7C,
    0xFF, 0x7F, 0x2F, 0x00, 0x60, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x00, 0xFF,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x03,
    0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x00 },
  { 0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E,
    0x00, 0x00, 0x1C, 0x00, 0xE0, 0xAF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 },
  { 0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xCD, 0x23, 0x00, 0x00, 0x00, 0xB0,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xBF, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x03,
    0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00 },
  { 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x0D, 0x00, 0x3F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x96, 0x25, 0xF0, 0xFE, 0xAE, 0x6C, 0x0D, 0x20,
    0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF,
    0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00 },
  { 0xED, 0xDA, 0x07, 0x00, 0x00, 0x00, 0x00, 0x50, 0x01, 0x50, 0x31, 0x82,
    0xAB, 0x62, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xC9, 0x80, 0xF5,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03 },
  { 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA,
    0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F,
    0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 0xDC, 0x1F },
  { 0x00, 0x00, 0x00, 0x00, 0x40, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07 },
  { 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x80, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFB, 0xFF, 0xFF, 0xBB,
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x07, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0xFF, 0x9F, 0x3D, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xFF, 0x3F, 0x1E, 0x00,
    0x0C, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
    0x9F, 0x39, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00 },
  { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x87, 0x39, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
    0xBF, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x8F, 0x39, 0xC0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
    0xC7, 0x3D, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xDF, 0x3D, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
    0xDF, 0x3D, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xCF, 0x3D, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x07, 0x80, 0x7F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x1B,
    0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xA0, 0xC2, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xDF, 0x0F, 0xBF, 0xFE, 0xFF, 0x3F, 0xFE, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x1F, 0x02, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70 },
  { 0x00, 0x26, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
};

static unsigned char lexer_blockmaps[5][256] = {
  { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A,
    0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x11, 0x12, 0x07, 0x13, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x14, 0x15, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x17,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07 },
  { 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x18, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x16, 0x16, 0x16, 0x19, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07 },
  { 0x1B, 0x07, 0x07, 0x07, 0x07, 0x07, 0x1C, 0x07, 0x07, 0x1D, 0x1D, 0x1E,
    0x1D, 0x1F, 0x20, 0x21, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07 },
  { 0x07, 0x07, 0x07, 0x22, 0x23, 0x24, 0x25, 0x07, 0x07, 0x26, 0x27, 0x28,
    0x29, 0x2A, 0x2B, 0x2C, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x2D, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x2E, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07 },
  { 0x2F, 0x07, 0x30, 0x31, 0x07, 0x07, 0x32, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x33, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x34, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07 },
};

static const Py_UCS4 lexer_INITIAL_pattern_0[] = { 11, 4, 6, 95, 1, 18, 
  11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 12, 51, 0, 11, 
  7, 8, 4, 3, 26, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 
  1, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 7, 8, 4, 4, 4, 0, 
  1, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_1[] = { 11, 4, 6, 95, 1, 18, 
  11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 12, 51, 0, 11, 
  7, 8, 4, 3, 26, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 
  1, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 7, 8, 4, 4, 4, 0, 
  1, 0, 1, 6, 58, 11, 4, 6, 95, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 
  4, 1, 0, 1, 0, 1, 0, 12, 51, 0, 11, 7, 8, 4, 3, 26, 0, 1, 18, 11, 7, 
  8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 
  8, 4, 4, 3, 0, 1, 7, 8, 4, 4, 4, 0, 1, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_2[] = { 12, 8, 1, 8, 4, 3, 53, 
  0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_3[] = { 5, 1 };

static const Py_UCS4 *lexer_INITIAL_patterns[] = {
  lexer_INITIAL_pattern_0,
  lexer_INITIAL_pattern_1,
  lexer_INITIAL_pattern_2,
  lexer_INITIAL_pattern_3,
  NULL
};

static const Py_UCS4 lexer_SCHEME_DATA_pattern_0[] = { 12, 8, 1, 9, 4, 
  3, 54, 0, 1, 1 };

static const Py_UCS4 lexer_SCHEME_DATA_pattern_1[] = { 6, 94, 8, 4, 3, 
  54, 0, 1 };

static const Py_UCS4 lexer_SCHEME_DATA_pattern_2[] = { 5, 1 };

static const Py_UCS4 *lexer_SCHEME_DATA_patterns[] = {
  lexer_SCHEME_DATA_pattern_0,
  lexer_SCHEME_DATA_pattern_1,
  lexer_SCHEME_DATA_pattern_2,
  NULL
};

static const Py_UCS4 **lexer_patterns[] = {
  NULL,
  lexer_INITIAL_patterns,
  lexer_SCHEME_DATA_patterns
};

static const int lexer_INITIAL_actions[] = { 0, 1, 2, 3 };

static const int lexer_SCHEME_DATA_actions[] = { 4, 5, 6 };

static const int *lexer_actions[] = {
  NULL,
  lexer_INITIAL_actions,
  lexer_SCHEME_DATA_actions
};

#if PY_VERSION_HEX < 0x02020000 || !defined(Py_USING_UNICODE)
#error "Python 2.2+ with unicode support required"
#endif

/* Static Definitions */
#define YYEMPTY -2
#define YYERROR -1
#define YYEOF 0
#define YYINITDEPTH 1000
#define LEXER_INITIAL_BACKTRACKS 20

/* Parsing objects */
typedef struct {
  PyObject_HEAD
  int verbose;
  PyObject *dict;
} parserobject;

typedef struct {
  PyObject *text;
  int last;
  int state;
  Py_UNICODE *end;
  Py_UNICODE *position;

  /* backtracking stack */
  int backtracks;
  Py_UNICODE **positions;
  int allocated;
} lexerobject;

static int parser_yylex(parserobject *, lexerobject *, PyObject **);
static lexerobject *lexer_new(PyObject *);
static void lexer_free(lexerobject *);
static int lexer_save_position(lexerobject *);
static Py_UNICODE *lexer_restore_position(lexerobject *);
static int lexer_charset(parserobject *, Py_UCS4 *, Py_UCS4, int);
static int lexer_match(parserobject *, lexerobject *, Py_UCS4 *);
static void lexer_error(lexerobject *);

static char *unicode_escape(Py_UNICODE *, int);
static PyObject *report_error(int state, PyObject *lval, lexerobject *lexer);
static void print_reduce(int ruleno);
static void print_state_stack(int *stack, int *end);

/* Parser Methods */

/* Attempt to use C99 variable argument macros for improved error detection
 * (just in case). 
 */
#ifdef __STDC__ /* C99 conformance macro */
#define TRACE(...) if (self->verbose > 0) PySys_WriteStderr(__VA_ARGS__)
#define REGEX_TRACE(...) if (self->verbose > 1) PySys_WriteStderr(__VA_ARGS__)
#else
#define TRACE if (self->verbose > 0) PySys_WriteStderr
#define REGEX_TRACE if (self->verbose > 1) PySys_WriteStderr
#endif

static char parse_doc[] = "\
parse(string) -> object\n\
Converts the given string to a parse tree and return the top-most\n\
element of the tree.";

static PyObject* parser_parse(register parserobject *self, PyObject *text)
{
  register int yystate;
  register int yyn;

  PyObject *yylval = NULL;
  PyObject *yyval = NULL;

  int state_stack[YYINITDEPTH];
  int *state_ptr;
  PyObject *value_stack[YYINITDEPTH];
  PyObject **value_ptr;

  int yylen;
  int yychar = YYEMPTY;         /* cause a token to be read */
  int yychar1 = 0;

  lexerobject *lexer;

  lexer = lexer_new(text);
  if (lexer == NULL)
    return NULL;

  TRACE("Starting parse\n");

  /* Initialize stack pointers
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized. */
  state_ptr = state_stack - 1;
  value_ptr = value_stack;

  yystate = 0;

  while (1) {
    /* Push a new state, which is found in yystate. */
    /* In all cases, when you get here, the value and location stacks
       have just been pushed.  So pushing a state here evens the stacks. */
    *++state_ptr = yystate;

    TRACE("Entering state %d\n", yystate);

    /* Do appropriate processing given the current state. */
    /* Read a lookahead token if we need one and don't already have one. */

    /* First try to decide what to do without reference to lookahead token. */
    yyn = action_idx[yystate];
    if (yyn == YYFLAG) {
      yyn = default_action[yystate];
      if (yyn == 0) {
        return report_error(yystate, yylval, lexer);
      }

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 1: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 21
   * XPointer: Shorthand
   */
  yyval = PyObject_CallMethod(XPointer, "Shorthand", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--XPointer(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 2: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 30
   * XPointer: SchemeBased
   */
  yyval = PyObject_CallMethod(XPointer, "SchemeBased", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--XPointer(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 52
   * SchemeBased: PointerPart
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SchemeBased(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 5: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 63
   * SchemeBased: SchemeBased PointerPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeBased(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 81
   * PointerPart: SchemeName '(' SchemeData ')'
   */
  lexer->state = LEXER_INITIAL;
  yyval = PyObject_CallMethod(XPointer, "Scheme", "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PointerPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 7: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 100
   * SchemeName: NCName
   */
  lexer->state = LEXER_SCHEME_DATA;
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 8: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 112
   * SchemeName: QName
   */
  lexer->state = LEXER_SCHEME_DATA;
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 9: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 129
   * SchemeData:
   */
  yyval = PyUnicode_FromUnicode(NULL, 0);
  if (self->verbose) {
    fprintf(stderr, "--SchemeData(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 10: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 137
   * SchemeData: EscapedDataList
   */
  PyObject *empty = PyUnicode_FromUnicode(NULL, 0);
  yyval = PyUnicode_Join(empty, value_ptr[1]);
  Py_DECREF(empty);
  if (self->verbose) {
    fprintf(stderr, "--SchemeData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 11: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 153
   * EscapedDataList: EscapedData
   */
  yyval = PyList_New(1);
  if (yyval) {
    PyList_SET_ITEM(yyval, 0, value_ptr[1]);
    Py_INCREF(value_ptr[1]);
  }
  if (self->verbose) {
    fprintf(stderr, "--EscapedDataList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 12: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 166
   * EscapedDataList: EscapedDataList EscapedData
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--EscapedDataList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 189
   * EscapedData: EscapedChar
   */
  yyval = PyUnicode_FromUnicode(PyUnicode_AS_UNICODE(value_ptr[1])+1, 1);
  if (self->verbose) {
    fprintf(stderr, "--EscapedData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 15: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 198
   * EscapedData: '(' SchemeData ')'
   */
  yyval = PyUnicode_FromUnicode(NULL, PyUnicode_GET_SIZE(value_ptr[2]) + 2);
  if (yyval) {
    PyUnicode_AS_UNICODE(yyval)[0] = '(';
    Py_UNICODE_COPY(PyUnicode_AS_UNICODE(yyval) + 1,
                    PyUnicode_AS_UNICODE(value_ptr[2]),
                    PyUnicode_GET_SIZE(value_ptr[2]));
    PyUnicode_AS_UNICODE(yyval)[PyUnicode_GET_SIZE(value_ptr[2]) + 1] = ')';
  }
  if (self->verbose) {
    fprintf(stderr, "--EscapedData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);


      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    } /* if (yyn == YYFLAG) */

    /* Not known => get a lookahead token if don't already have one. */

    /* yychar is either YYEMPTY, YYEOF or a valid token in external form */
    if (yychar == YYEMPTY) {
      TRACE("Reading a token: ");
      yychar = parser_yylex(self, lexer, &yylval);
    }

    /* Convert token to internal form (in yychar1) for indexing tables with */

    if (yychar <= 0) {
      if (yychar == YYERROR) {
        lexer_free(lexer);
        return NULL;
      }
      /* This means end-of-input. */
      yychar1 = 0;
      TRACE("Now at end of input.\n");
    } else {
      yychar1 = YYTRANSLATE(yychar);
      TRACE("Next token is %d (%s)\n", yychar, token_names[yychar1]);
      yyn += yychar1;
    }
    if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1) {
      /* comes here after end of input */
      yyn = default_action[yystate];
      if (yyn == 0) {
        return report_error(yystate, NULL, lexer);
      }

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 1: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 21
   * XPointer: Shorthand
   */
  yyval = PyObject_CallMethod(XPointer, "Shorthand", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--XPointer(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 2: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 30
   * XPointer: SchemeBased
   */
  yyval = PyObject_CallMethod(XPointer, "SchemeBased", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--XPointer(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 52
   * SchemeBased: PointerPart
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SchemeBased(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 5: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 63
   * SchemeBased: SchemeBased PointerPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeBased(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 81
   * PointerPart: SchemeName '(' SchemeData ')'
   */
  lexer->state = LEXER_INITIAL;
  yyval = PyObject_CallMethod(XPointer, "Scheme", "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PointerPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 7: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 100
   * SchemeName: NCName
   */
  lexer->state = LEXER_SCHEME_DATA;
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 8: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 112
   * SchemeName: QName
   */
  lexer->state = LEXER_SCHEME_DATA;
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 9: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 129
   * SchemeData:
   */
  yyval = PyUnicode_FromUnicode(NULL, 0);
  if (self->verbose) {
    fprintf(stderr, "--SchemeData(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 10: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 137
   * SchemeData: EscapedDataList
   */
  PyObject *empty = PyUnicode_FromUnicode(NULL, 0);
  yyval = PyUnicode_Join(empty, value_ptr[1]);
  Py_DECREF(empty);
  if (self->verbose) {
    fprintf(stderr, "--SchemeData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 11: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 153
   * EscapedDataList: EscapedData
   */
  yyval = PyList_New(1);
  if (yyval) {
    PyList_SET_ITEM(yyval, 0, value_ptr[1]);
    Py_INCREF(value_ptr[1]);
  }
  if (self->verbose) {
    fprintf(stderr, "--EscapedDataList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 12: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 166
   * EscapedDataList: EscapedDataList EscapedData
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--EscapedDataList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 189
   * EscapedData: EscapedChar
   */
  yyval = PyUnicode_FromUnicode(PyUnicode_AS_UNICODE(value_ptr[1])+1, 1);
  if (self->verbose) {
    fprintf(stderr, "--EscapedData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 15: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 198
   * EscapedData: '(' SchemeData ')'
   */
  yyval = PyUnicode_FromUnicode(NULL, PyUnicode_GET_SIZE(value_ptr[2]) + 2);
  if (yyval) {
    PyUnicode_AS_UNICODE(yyval)[0] = '(';
    Py_UNICODE_COPY(PyUnicode_AS_UNICODE(yyval) + 1,
                    PyUnicode_AS_UNICODE(value_ptr[2]),
                    PyUnicode_GET_SIZE(value_ptr[2]));
    PyUnicode_AS_UNICODE(yyval)[PyUnicode_GET_SIZE(value_ptr[2]) + 1] = ')';
  }
  if (self->verbose) {
    fprintf(stderr, "--EscapedData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);

      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    }

    yyn = yytable[yyn];

    /* yyn is what to do for this token type in this state.
       Negative => reduce, -yyn is rule number.
       Positive => shift, yyn is new state.
         New state is final state => don't bother to shift
         just return success.
       0, or max negative number => error. */

    if (yyn > YYFLAG && yyn < 0) {
      yyn = -yyn;

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 1: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 21
   * XPointer: Shorthand
   */
  yyval = PyObject_CallMethod(XPointer, "Shorthand", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--XPointer(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 2: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 30
   * XPointer: SchemeBased
   */
  yyval = PyObject_CallMethod(XPointer, "SchemeBased", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--XPointer(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 52
   * SchemeBased: PointerPart
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SchemeBased(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 5: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 63
   * SchemeBased: SchemeBased PointerPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeBased(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 81
   * PointerPart: SchemeName '(' SchemeData ')'
   */
  lexer->state = LEXER_INITIAL;
  yyval = PyObject_CallMethod(XPointer, "Scheme", "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--PointerPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 7: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 100
   * SchemeName: NCName
   */
  lexer->state = LEXER_SCHEME_DATA;
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 8: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 112
   * SchemeName: QName
   */
  lexer->state = LEXER_SCHEME_DATA;
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--SchemeName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 9: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 129
   * SchemeData:
   */
  yyval = PyUnicode_FromUnicode(NULL, 0);
  if (self->verbose) {
    fprintf(stderr, "--SchemeData(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 10: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 137
   * SchemeData: EscapedDataList
   */
  PyObject *empty = PyUnicode_FromUnicode(NULL, 0);
  yyval = PyUnicode_Join(empty, value_ptr[1]);
  Py_DECREF(empty);
  if (self->verbose) {
    fprintf(stderr, "--SchemeData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 11: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 153
   * EscapedDataList: EscapedData
   */
  yyval = PyList_New(1);
  if (yyval) {
    PyList_SET_ITEM(yyval, 0, value_ptr[1]);
    Py_INCREF(value_ptr[1]);
  }
  if (self->verbose) {
    fprintf(stderr, "--EscapedDataList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 12: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 166
   * EscapedDataList: EscapedDataList EscapedData
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--EscapedDataList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 189
   * EscapedData: EscapedChar
   */
  yyval = PyUnicode_FromUnicode(PyUnicode_AS_UNICODE(value_ptr[1])+1, 1);
  if (self->verbose) {
    fprintf(stderr, "--EscapedData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 15: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 198
   * EscapedData: '(' SchemeData ')'
   */
  yyval = PyUnicode_FromUnicode(NULL, PyUnicode_GET_SIZE(value_ptr[2]) + 2);
  if (yyval) {
    PyUnicode_AS_UNICODE(yyval)[0] = '(';
    Py_UNICODE_COPY(PyUnicode_AS_UNICODE(yyval) + 1,
                    PyUnicode_AS_UNICODE(value_ptr[2]),
                    PyUnicode_GET_SIZE(value_ptr[2]));
    PyUnicode_AS_UNICODE(yyval)[PyUnicode_GET_SIZE(value_ptr[2]) + 1] = ')';
  }
  if (self->verbose) {
    fprintf(stderr, "--EscapedData(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);

      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    } else if (yyn == YYFINAL) {
      /* Hooray!  Process complete. */
      lexer_free(lexer);
      return value_ptr[-1];
    } else if (yyn <= 0) {
      /* Now it is either 0 or YYFLAG */
      return report_error(yystate, yylval, lexer);
    }

    /* Shift the lookahead token. */

    TRACE("Shifting token %d (%s), ", yychar, token_names[yychar1]);

    if (yychar != YYEOF) {
      yychar = YYEMPTY;
    }

    *++value_ptr = yylval;

    yystate = yyn;
    continue;
  }

  /* should never get here */
  Py_INCREF(Py_None);
  lexer_free(lexer);
  return Py_None;
}

/** lexer routines ****************************************************/

static lexerobject *lexer_new(PyObject *text)
{
  lexerobject *lexer;

  lexer = PyMem_New(lexerobject, 1);
  if (lexer == NULL) {
    PyErr_NoMemory();
    return NULL;
  }

  /* attempt to coerce given object to unicode using default rules */
  lexer->text = PyUnicode_FromObject(text);
  if (lexer->text == NULL) {
    PyMem_Free(lexer);
    return NULL;
  }
  lexer->position = PyUnicode_AS_UNICODE(lexer->text);
  lexer->end = lexer->position + PyUnicode_GET_SIZE(lexer->text);
  lexer->state = LEXER_START_STATE;

  /* create initial backtracking stack */
  lexer->positions = PyMem_New(Py_UNICODE *, LEXER_INITIAL_BACKTRACKS);
  if (lexer->positions == NULL) {
    PyErr_NoMemory();
    Py_DECREF(lexer->text);
    PyMem_Free(lexer);
    return NULL;
  }
  lexer->allocated = LEXER_INITIAL_BACKTRACKS;
  lexer->backtracks = 0;
  return lexer;
}

static void lexer_free(lexerobject *lexer)
{
  PyMem_Free(lexer->positions);
  Py_DECREF(lexer->text);
  PyMem_Free(lexer);
}

static int lexer_save_position(lexerobject *lexer) {
  Py_UNICODE **positions;
  size_t new_allocated;
  int allocated, newsize;

  /* Bypass realloc() when a previous overallocation is large enough
     to accommodate the newsize.
  */
  newsize = lexer->backtracks + 1;
  allocated = lexer->allocated;
  positions = lexer->positions;
  if (newsize >= allocated) {
    /* This over-allocates proportional to the list size, making room
     * for additional growth.  The over-allocation is mild, but is
     * enough to give linear-time amortized behavior over a long
     * sequence of appends() in the presence of a poorly-performing
     * system realloc().
     * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
     */
    new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6) + newsize;
    if (PyMem_Resize(positions, Py_UNICODE *, new_allocated) == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    lexer->allocated = new_allocated;
    lexer->positions = positions;
  }
  lexer->positions[lexer->backtracks] = lexer->position;
  lexer->backtracks = newsize;
  return 0;
}

static Py_UNICODE *lexer_restore_position(lexerobject *lexer) {
  assert(lexer->backtracks > 0);
  lexer->position = lexer->positions[--lexer->backtracks];
  return lexer->position;
}

static int lexer_charset(parserobject *self, Py_UCS4 *set, Py_UCS4 ch,
			 int ok)
{
  unsigned char *charset;

  /* check if character is a member of the given set */
  /* Note, the tests are stored sorted to allow for quick exits */

  for (;;) {
    switch (*set++) {

    case LEXER_CHARSET_LITERAL:
      /* <LITERAL> <code> */
      REGEX_TRACE("CHARSET_LITERAL, %d == %d\n", ch, set[0]);
      if (ch < set[0])
        return !ok;
      else if ((Py_UCS4)ch == set[0])
        return ok;
      set++;
      break;

    case LEXER_CHARSET_RANGE:
      /* <RANGE> <lower> <upper> */
      REGEX_TRACE("CHARSET_RANGE, %d <= %d <= %d\n", set[0], ch, set[1]);
      if (ch < set[0])
        return !ok;
      else if (ch <= set[1])
        return ok;
      set += 2;
      break;

    case LEXER_CHARSET_SMALL:
      /* <SMALL> <charset index> */
      REGEX_TRACE("CHARSET_SMALL, index=%d\n", set[0]);
      charset = lexer_charsets[*set++];
      if (ch < 256 && (charset[ch >> 3] & (1 << (ch & 7))))
        return ok;
      break;

    case LEXER_CHARSET_BIG:
      /* <BIG> <blockmap index> */
      REGEX_TRACE("CHARSET_BIG, index=%d\n", set[0]);
      charset = lexer_charsets[lexer_blockmaps[*set++][ch >> 8]];
      if (ch < 65536 && charset[(ch & 255) >> 3] & (1 << (ch & 7)))
        return ok;
      break;

    case LEXER_CHARSET_FAILURE:
      /* nothing matched in charset */
      REGEX_TRACE("CHARSET_FAILURE\n");
      return !ok;

    default:
      REGEX_TRACE("**INTERNAL CHARSET ERROR**\n");
      return -1;
    }
  }
}

/* return values:
   1 -> sucessful match,
   0 -> no match,
   -1 -> error,
*/

#ifdef Py_UNICODE_WIDE
#define GET_CHAR_AND_ADVANCE() ch = *ptr++;
#else
#define GET_CHAR_AND_ADVANCE()                                          \
  if ((0xD800 <= ptr[0] && ptr[0] <= 0xDBFF) &&                         \
      (0xDC00 <= ptr[1] && ptr[1] <= 0xDFFF)) {                         \
    ch = (((ptr[0] & 0x03FF) << 10) | (ptr[1] & 0x03FF)) + 0x00010000;  \
    ptr += 2;                                                           \
  } else {                                                              \
    ch = *ptr++;                                                        \
  }
#endif  
    
static int lexer_match(parserobject *self, lexerobject *lexer, 
		       Py_UCS4 *pattern)
{
  Py_UNICODE *ptr = lexer->position;
  Py_UNICODE *end;
  Py_UCS4 ch;
  int i, count;

  REGEX_TRACE("LEXER_MATCH, position %" YY_FORMAT_SIZE_T "d\n",
              lexer->position - PyUnicode_AS_UNICODE(lexer->text));

  while (1) {
    switch (*pattern++) {

    case LEXER_OP_FAILURE:
      /* immediate failure */
      REGEX_TRACE("OP_FAILURE\n");
      return 0;

    case LEXER_OP_SUCCESS:
      /* end of pattern */
      REGEX_TRACE("OP_SUCCESS\n");
      lexer->position = ptr;
      return 1;
        
    case LEXER_OP_BOL:
      /* beginning of line */
      /* <BOL> */
      REGEX_TRACE("OP_BOL\n");
      if (ptr == PyUnicode_AS_UNICODE(lexer->text) || ptr[-1] == '\n') 
        break;
      return 0;

    case LEXER_OP_EOL:
      /* end of line */
      /* <EOL> */
      REGEX_TRACE("OP_EOL\n");
      if (ptr >= lexer->end || ptr[0] == '\n') break;
      return 0;
            
    case LEXER_OP_EOF:
      /* end of file */
      /* <EOF> */
      REGEX_TRACE("OP_EOF\n");
      if (ptr >= lexer->end) break;
      return 0;

    case LEXER_OP_ANY:
      /* match anything (except a newline) */
      /* <ANY> */
      REGEX_TRACE("OP_ANY\n");
      if (ptr >= lexer->end || ptr[0] == '\n')
        return 0;
      ptr++;
      break;

    case LEXER_OP_LITERAL:
      /* match literal character */
      /* <LITERAL> <code> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_LITERAL, %d == %d\n", ch, pattern[0]);
      if (ch != pattern[0])
        return 0;
      pattern++;
      break;

    case LEXER_OP_NOT_LITERAL:
      /* match anything that is not literal character */
      /* <NOT_LITERAL> <code> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_NOT_LITERAL, %d != %d\n", ch, pattern[0]);
      if (ch == pattern[0])
        return 0;
      pattern++;
      break;

    case LEXER_OP_CHARSET:
      /* match set member */
      /* <CHARSET> <skip> <set> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_CHARSET, skip %d\n", pattern[0]);
      i = lexer_charset(self, pattern + 1, ch, 1);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;
            
    case LEXER_OP_NOT_CHARSET:
      /* match set non-member */
      /* <NOT_CHARSET> <skip> <set> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_NOT_CHARSET, skip %d\n", pattern[0]);
      i = lexer_charset(self, pattern + 1, ch, 0);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;
            
    case LEXER_OP_ASSERT:
      /* lookahead assertion */
      /* <ASSERT> <skip> <pattern> */
      REGEX_TRACE("OP_ASSERT, skip %d\n", pattern[0]);
      lexer->position = ptr;
      i = lexer_match(self, lexer, pattern + 1);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;

    case LEXER_OP_BRANCH:
      /* alternation */
      /* <BRANCH> <skip0> <code0> <skip1> <code1> ... <NULL> */

      end = NULL;
      count = 0;
      while (pattern[0]) {
        /* reset start position each time through */
	REGEX_TRACE("OP_BRANCH %d, skip %d\n", count++, pattern[0]);
        lexer->position = ptr;
        
        i = lexer_match(self, lexer, pattern + 1);
        if (i < 0)
          return i;
        else if (i && lexer->position > end) 
          /* successful match which is longer than the current best matched */
          end = lexer->position;
        
        /* advance to the next pattern */
        pattern += pattern[0];
      }

      /* advance pattern past NULL */
      pattern++;

      /* advance to the best matching position if there was a match */
      if (end) {
        lexer->position = ptr = end;
        break;
      }

      return 0;

    case LEXER_OP_REPEAT:
      /* repetition */
      /* <REPEAT> <skip> <1=min> item */
      {
        Py_UCS4 *item = pattern + 2;
        Py_UCS4 *next = pattern + pattern[0];
        int minimum = pattern[1];
        int backtracks;

        lexer->position = ptr;
        for (count = 0, i = 1; i == 1 && count < minimum; count++) {
          REGEX_TRACE("OP_REPEAT<stage 1>, min %d, now %d\n",
                      minimum, count);
          i = lexer_match(self, lexer, item);
        }
        
        /* either internal error or failed minimum matches */
        if (i <= 0) 
          return i;

        backtracks = lexer->backtracks;

        /* match as many items as possible */
        for (; i == 1; count++) {
          REGEX_TRACE("OP_REPEAT<stage 2>, now %d\n", count);
          if (lexer_save_position(lexer) < 0)
            return -1;
          i = lexer_match(self, lexer, item);
        }
          
        if (i < 0) {
          /* internal error */
          lexer->backtracks = backtracks;
          return i;
        }
          
        /* backtracking assert of tail match until success */
        do {
          REGEX_TRACE("OP_REPEAT<stage 3>, now %d\n", count);
          /* update position to previous successful match */
          ptr = lexer_restore_position(lexer);
          if (ptr == NULL)
            return -1;
          i = lexer_match(self, lexer, next);
        } while (i == 0 && --count > minimum);

        /* discard remaining backtrack positions */
        lexer->backtracks = backtracks;

        if (i <= 0) {
          return i;
        }
        pattern = next;
      }
      break;

    case LEXER_OP_REPEAT_RANGE:
      /* repetition */
      /* <REPEAT_RANGE> <skip> <1=min> <2=max> item */
      {
        Py_UCS4 *item = pattern + 3;
        Py_UCS4 *next = pattern + pattern[0];
        int minimum = pattern[1];
        int maximum = pattern[2];
        int backtracks;

        lexer->position = ptr;
        for (count = 0, i = 1; i == 1 && count < minimum; count++) {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 1>, min %d, now %d\n",
                      minimum, count);
          i = lexer_match(self, lexer, item);
        }
        
        /* either internal error or failed minimum matches */
        if (i <= 0) 
          return i;

        backtracks = lexer->backtracks;

        /* consume up to 'maximum' matches */
        for (; i == 1 && count < maximum; count++) {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 2>, max %d, now %d\n",
                      maximum, count);
          if (lexer_save_position(lexer) < 0)
            return -1;
          i = lexer_match(self, lexer, item);
        }

        if (i < 0) {
          /* internal error */
          lexer->backtracks = backtracks;
          return i;
        }

        /* maximum matches reached, update saved position */
        if (i == 1)
          ptr = lexer->position;

        /* backtracking assert of tail match until success */
        do {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 3>, now %d\n", count);
          if (i == 0) {
            /* update position to last successful match */
            ptr = lexer_restore_position(lexer);
            if (ptr == NULL)
              return -1;
          }
          i = lexer_match(self, lexer, next);
        } while (i == 0 && --count > minimum);

        /* discard remaining backtrack positions */
        lexer->backtracks = backtracks;

        if (i <= 0)
          return i;

        pattern = next;
      }
      break;

    default:
      REGEX_TRACE("**INTERNAL MATCH ERROR**\n");
      return -1;
    }
  }
}

static int parser_yylex(parserobject *self, lexerobject *lexer,
			PyObject **yylval)
{
  int yychar = YYEMPTY;
  int yylen;
  Py_UNICODE *yytext = lexer->position;
  
  while (yytext < lexer->end && yychar == YYEMPTY) {
    Py_UNICODE *best_end = NULL;
    int yyaccept = 0;
    int i;
    Py_UCS4 **patterns = (Py_UCS4 **)lexer_patterns[lexer->state];
    const int *actions = lexer_actions[lexer->state];

    REGEX_TRACE("Using patterns from lexer state %d\n", lexer->state);
    for (i = 0; patterns[i]; i++) {
      int matched;
      /* reset position each time through */
      lexer->position = yytext;

      REGEX_TRACE("--- pattern %d...\n", i);
      matched = lexer_match(self, lexer, patterns[i]);
      
      if (matched > 0 && lexer->position > best_end) {
        /* successful match which is longer than the current best matched */
        best_end = lexer->position;
        yyaccept = i;
      } else if (matched < 0) {
        /* internal error */
	REGEX_TRACE("--- pattern %d internal error\n", i);
        PyErr_SetString(PyExc_RuntimeError,
                        "internal error in regular expression engine");
        return -1;
      }
      REGEX_TRACE("--- pattern %d %s\n", i, matched ? "success" : "failed");
    }
      
    if (best_end == NULL) {
      /* no matches */
      lexer->position = yytext;
      lexer_error(lexer);
      return -1;
    }

    lexer->position = best_end;
    yylen = best_end - yytext;

    /* get the action block for this match */
    switch (actions[yyaccept]) {
case 0: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 232 */
  TRACE("using rule from Ft/Xml/XPointer/XPointer.bgen[232], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = NCName;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 1: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 237 */
  TRACE("using rule from Ft/Xml/XPointer/XPointer.bgen[237], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = QName;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 2: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 241 */
  TRACE("using rule from Ft/Xml/XPointer/XPointer.bgen[241], ");
  /* skip over the matched text */
  yytext = lexer->position;
  break;
}
case 3: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 243 */
  TRACE("using rule from Ft/Xml/XPointer/XPointer.bgen[243], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = (int)*yytext;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 4: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 249 */
  TRACE("using rule from Ft/Xml/XPointer/XPointer.bgen[249], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = NormalChar;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 5: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 253 */
  TRACE("using rule from Ft/Xml/XPointer/XPointer.bgen[253], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = EscapedChar;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 6: {
  /* from Ft/Xml/XPointer/XPointer.bgen, line 257 */
  TRACE("using rule from Ft/Xml/XPointer/XPointer.bgen[257], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = (int)*yytext;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
    }
  }

  if (yychar == YYEMPTY) {
    /* Reached end of input */
    yychar = YYEOF;
  }

  return yychar;
}

/** Type Object *******************************************************/

static int parser_traverse(parserobject *self, visitproc visit, void *arg)
{
  int rv;

  if (self->dict) {
    rv = visit(self->dict, arg);
    if (rv != 0) return rv;
  }
  return 0;
}

static int parser_clear(parserobject *self)
{
  PyObject *tmp;

  if (self->dict) {
    tmp = self->dict;
    self->dict = NULL;
    Py_DECREF(tmp);
  }
  return 0;
}

static void parser_dealloc(parserobject *self)
{
  parser_clear(self);
  self->ob_type->tp_free((PyObject *) self);
}

static int parser_init(parserobject *self, PyObject *args, PyObject *kwds)
{
  PyObject *debug=NULL;
  static char *kwlist[] = { "debug", NULL };

  if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:" PARSER_NAME, kwlist,
                                   &debug))
    return -1;

  if (debug) {
    self->verbose = PyObject_IsTrue(debug);
  }

  return 0;
}

static PyObject *parser_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  parserobject *self;

  self = (parserobject *) type->tp_alloc(type, 0);
  if (self != NULL) {
    self->dict = PyDict_New();
    if (self->dict == NULL) {
      Py_DECREF(self);
      return NULL;
    }
    self->verbose = 0;
  }
  return (PyObject *) self;
}

static PyMethodDef parser_methods[] = {
  { "parse", (PyCFunction) parser_parse, METH_O, parse_doc },
  { NULL, NULL }
};

static PyMemberDef parser_members[] = {
  { "debug", T_INT, offsetof(parserobject, verbose) },
  { NULL }
};

static char parser_doc[] = PARSER_NAME "\
([debug]) -> parser\n\
Create a new parser object.\n\
\n\
The optional debug argument, when true, enables the builtin trace facility.\n\
The trace facility uses stderr to display each step taken by the parser.";

static PyTypeObject Parser_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ PROJECT_NAME "." PARSER_NAME,
  /* tp_basicsize      */ sizeof(parserobject),
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) parser_dealloc,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) 0,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
  /* tp_doc            */ (char *) parser_doc,
  /* tp_traverse       */ (traverseproc) parser_traverse,
  /* tp_clear          */ (inquiry) parser_clear,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) parser_methods,
  /* tp_members        */ (PyMemberDef *) parser_members,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ offsetof(parserobject, dict),
  /* tp_init           */ (initproc) parser_init,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) parser_new,
  /* tp_free           */ 0,
};

/* Helper functions */

/* caller is responsible for releasing the memory */
static char *unicode_escape(Py_UNICODE *s, int len)
{
  static const char *hexdigit = "0123456789ABCDEF";
  char *repr, *p;
  int i, size;

  /* Do one pass to get the repr'ed size */
  size = 1;  /* zero terminator */
  for (i = 0; i < len; i++) {
#ifdef Py_UNICODE_WIDE
    if (s[i] >= 65536) size += 10;  /* \UHHHHHHHH */
    else
#endif
    if (s[i] >= 256) size += 6;  /* \uHHHH */
    else if (s[i] == 9 || s[i] == 10 || s[i] == 13) size += 2;  /* \t \n \r */
    else if (s[i] < 32 || s[i] >= 128) size += 4;  /* \xHH */
    else size++; /* printable US-ASCII */
  }
  
  repr = p = PyMem_New(char, size + 1);
  if (repr == NULL) return NULL;

  while (len-- > 0) {
    Py_UNICODE ch = *s++;
#ifdef Py_UNICODE_WIDE
    /* Map 32-bit characters to '\Uxxxxxxxx' */
    if (ch >= 65536) {
      *p++ = '\\';
      *p++ = 'U';
      *p++ = hexdigit[(ch >> 28) & 0xf];
      *p++ = hexdigit[(ch >> 24) & 0xf];
      *p++ = hexdigit[(ch >> 20) & 0xf];
      *p++ = hexdigit[(ch >> 16) & 0xf];
      *p++ = hexdigit[(ch >> 12) & 0xf];
      *p++ = hexdigit[(ch >> 8) & 0xf];
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Map 16-bit characters to '\uxxxx' */
    else 
#endif
    if (ch >= 256) {
      *p++ = '\\';
      *p++ = 'u';
      *p++ = hexdigit[(ch >> 12) & 0xf];
      *p++ = hexdigit[(ch >> 8) & 0xf];
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Map special whitespace to '\t', \n', '\r' */
    else if (ch == 9) {
      *p++ = '\\';
      *p++ = 't';
    }
    else if (ch == 10) {
      *p++ = '\\';
      *p++ = 'n';
    }
    else if (ch == 13) {
      *p++ = '\\';
      *p++ = 'r';
    }
    /* Map non-printable US ASCII to '\xhh' */
    else if (ch < 32 || ch >= 128) {
      *p++ = '\\';
      *p++ = 'x';
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Copy everything else as-is */
    else
      *p++ = (char) ch;
  }

  *p = '\0';

  return repr;
}

static void calculate_position(lexerobject *lexer, int *line, int *column) {
  /* Determine line and column numbers */
  Py_UNICODE *p;

  *line = 1;
  *column = 1;

  for (p = PyUnicode_AS_UNICODE(lexer->text); p < lexer->end; p++) {
    if ((char)*p == '\n') {
      *line += 1;
      *column = 1;
    } else {
      *column += 1;
    }
  }
}

static const char error_format_str[] = "parse error at line %d, column %d: matched '%s'";
static const char error_format_eof_str[] = "parse error at line %d, column %d: reached end-of-input";

static PyObject *report_error(int state, PyObject* lval, lexerobject *lexer) {
  int line, column;
  int ruleno = action_idx[state];
  char *matched = NULL;

  if (lval) {
    matched = unicode_escape(PyUnicode_AS_UNICODE(lval), 
                             PyUnicode_GET_SIZE(lval));
    if (matched == NULL) return NULL;
  }

  calculate_position(lexer, &line, &column);
  Py_DECREF(lexer->text);

  if (ruleno > YYFLAG && ruleno < YYLAST) {
    /* There are expected tokens */
    int x, count;
    int size = 60;  /* Initial format string */
    char *msg;

    /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
    for (x = (ruleno < 0 ? -ruleno : 0);
         x < (sizeof(token_names) / sizeof(char *)); x++) {
      if (yycheck[x + ruleno] == x) {
        size += strlen(token_names[x]) + 15;
      }
    }

    msg = PyMem_New(char, size);
    if (msg == NULL) {
      PyMem_Del(matched);
      return NULL;
    }

    if (lval) {
      strcpy(msg, error_format_str);
    } else {
      strcpy(msg, error_format_eof_str);
    }

    count = 0;
    for (x = (ruleno < 0 ? -ruleno : 0);
         x < (sizeof(token_names) / sizeof(char *)); x++) {
      if (yycheck[x + ruleno] == x) {
        strcat(msg, count == 0 ? ", expecting '" : " or '");
        strcat(msg, token_names[x]);
        strcat(msg, "'");
        count++;
      }
    }
    if (matched) {
      PyErr_Format(PyExc_SyntaxError, msg, line, column, matched);
    } else {
      PyErr_Format(PyExc_SyntaxError, msg, line, column);
    }
    PyMem_Del(msg);
  } else {
    if (matched) {
      PyErr_Format(PyExc_SyntaxError, error_format_str, line, column, matched);
    } else {
      PyErr_Format(PyExc_SyntaxError, error_format_eof_str, line, column);
    }
  }

  if (matched) {
    PyMem_Del(matched);
  }

  return NULL;
}

static const char lexer_error_str[] = "lexical error at line %d, column %d: no action found for '%s'";

static void lexer_error(lexerobject *lexer)
{
  int line, column;
  char *repr = unicode_escape(lexer->position, (lexer->end - lexer->position));
  if (repr == NULL) return;

  calculate_position(lexer, &line, &column);

  PyErr_Format(PyExc_SyntaxError, lexer_error_str, line, column, repr);

  PyMem_Del(repr);
  return;
}

static void print_reduce(int ruleno) {
  int count;
  const int *token;

  PySys_WriteStderr("Reducing via rule %d (%s), ", ruleno, rule_info[ruleno]);
  /* print the symbols being reduced and their result. */

  count = ruleno;
  token = rhs_tokens;
  while (--count) while (*++token);

  while (*++token) {
    PySys_WriteStderr("%s ", token_names[*token]);
  }
  PySys_WriteStderr("-> %s\n", token_names[derives[ruleno]]);
}

static void print_state_stack(int *stack, int *end) {
  int *curr = stack;

  PySys_WriteStderr("state stack now");
  while (curr <= end) {
    PySys_WriteStderr(" %d", *curr++);
  }
  PySys_WriteStderr("\n");
}

/** Interactive parser ************************************************/

#define CONSOLE_NAME PARSER_NAME "Console"

typedef struct {
  PyObject_HEAD
  parserobject *parser;
  PyObject *dict;
} consoleobject;

static PyObject *console_new(PyTypeObject *type, PyObject *args,
			     PyObject *kwds)
{
  consoleobject *self;

  self = (consoleobject *) type->tp_alloc(type, 0);
  if (self != NULL) {
    PyObject *args = Py_BuildValue("(i)", 1);
    if (args == NULL) {
      Py_DECREF(self);
      return NULL;
    }
    self->parser = (parserobject *) parser_new(&Parser_Type, args, NULL);
    Py_DECREF(args);
    if (self->parser == NULL) {
      Py_DECREF(self);
      return NULL;
    }
  }
  return (PyObject *) self;
}

static int console_init(consoleobject *self, PyObject *args, PyObject *kwds)
{
  PyObject *bases, *base, *result;
  int size, i;

  if (!PyArg_ParseTuple(args, ":" CONSOLE_NAME)) return -1;

  bases = self->ob_type->tp_bases;
  size = PyTuple_GET_SIZE(bases);
  for (i = 0; i < size; i++) {
    base = PyTuple_GET_ITEM(bases, i);
    result = PyObject_CallMethod(base, "__init__", "O", (PyObject *) self);
    if (result == NULL) return -1;
    Py_DECREF(result);
  }
  return 0;
}

static void console_dealloc(consoleobject *self)
{
  Py_XDECREF(self->parser);
  self->ob_type->tp_free((PyObject *) self);
}

static PyObject *console_cmdloop(consoleobject *self, PyObject *args)
{
  PyObject *result=NULL, *builtins=NULL, *readline=NULL, *old_completer=NULL;
  int stop;

  builtins = PyImport_ImportModule("__builtin__");
  if (builtins == NULL) goto exit;

  readline = PyImport_ImportModule("readline");
  if (readline == NULL) {
    if (!PyErr_ExceptionMatches(PyExc_ImportError)) goto exit;
    PyErr_Clear();
  } else {
#if PY_VERSION_HEX > 0x02030000
    /* old_completer = readline.get_completer() */
    old_completer = PyObject_CallMethod(readline, "get_completer", NULL);
    if (old_completer == NULL) goto exit;
#endif
    /* readline.set_completer(self.complete) */
    result = PyObject_GetAttrString((PyObject *) self, "complete");
    if (result == NULL) goto exit;
    result = PyObject_CallMethod(readline, "set_completer", "N", result);
    if (result == NULL) goto exit;
    Py_DECREF(result);
    /* readline.parse_and_bind("tab: complete") */
    result = PyObject_CallMethod(readline, "parse_and_bind", "s",
				 "tab: complete");
    if (result == NULL) goto exit;
    Py_DECREF(result);
  }

  stop = 0;
  do {
    result = PyObject_GetAttrString((PyObject *) self, "prompt");
    if (result == NULL) goto finally;
    result = PyObject_CallMethod(builtins, "raw_input", "N", result);
    if (result == NULL) {
      if (PyErr_ExceptionMatches(PyExc_EOFError) ||
	  PyErr_ExceptionMatches(PyExc_KeyboardInterrupt)) {
	PyErr_Clear();
	PySys_WriteStdout("\n");
	Py_INCREF(Py_None);
	result = Py_None;
      }
      goto finally;
    }
    result = PyObject_CallMethod((PyObject *) self, "onecmd", "N", result);
    if (result == NULL) goto finally;
    stop = PyObject_IsTrue(result);
    Py_DECREF(result);
  } while (!stop);

  Py_INCREF(Py_None);
  result = Py_None;

 finally:
#if PY_VERSION_HEX > 0x02030000
  if (readline != NULL && old_completer != NULL) {
    PyObject *rv;
    rv = PyObject_CallMethod(readline, "set_completer", "O", old_completer);
    if (rv == NULL) {
      Py_XDECREF(result);
      result = rv;
    } else {
      Py_DECREF(rv);
    }
  }
#endif
 exit:
  Py_XDECREF(old_completer);
  Py_XDECREF(readline);
  Py_XDECREF(builtins);
  return result;
}

static PyObject *console_emptyline(consoleobject *self, PyObject *noarg)
{
  Py_INCREF(Py_None);
  return Py_None;
}

static char console_exit_doc[] = "terminate the console";

static PyObject *console_exit(consoleobject *self, PyObject *arg)
{
  Py_INCREF(Py_True);
  return Py_True;
}

static char console_debug_doc[] = "sets or displays the debug level";

static PyObject *console_debug(consoleobject *self, PyObject *arg)
{
  PyObject *verbose;

  if (PyObject_IsTrue(arg)) {
    if ((verbose = PyNumber_Int(arg)) == NULL) {
      if (PyErr_ExceptionMatches(PyExc_ValueError)) {
	PyErr_Clear();
	PySys_WriteStdout("usage: debug <level>\n");
	Py_INCREF(Py_None);
	return Py_None;
      }
      return NULL;
    }
    self->parser->verbose = PyInt_AsLong(verbose);
    Py_DECREF(verbose);
  }
  PySys_WriteStdout("debug level is %d\n", self->parser->verbose);
  Py_INCREF(Py_None);
  return Py_None;
}

static char console_parse_doc[] = "parses an expression";

static PyObject *console_parse(consoleobject *self, PyObject *arg)
{
  PyObject *result, *value;

  result = parser_parse(self->parser, arg);
  if (result == NULL) {
    PyObject *exc, *tb;
    if (!PyErr_ExceptionMatches(PyExc_SyntaxError)) return NULL;
    PyErr_Fetch(&exc, &value, &tb);
    if (value && value != Py_None) {
      result = PyObject_Str(value);
    }
    Py_XDECREF(exc);
    Py_XDECREF(value);
    Py_XDECREF(tb);
    if (result == NULL) return NULL;
  }

  value = PyObject_Str(result);
  Py_DECREF(result);
  if (value == NULL) return NULL;

  PySys_WriteStdout("%s\n", PyString_AsString(value));
  Py_DECREF(value);

  Py_INCREF(Py_None);
  return Py_None;
}

static PyMethodDef console_methods[] = {
  { "cmdloop", (PyCFunction) console_cmdloop, METH_O },
  { "emptyline", (PyCFunction) console_emptyline, METH_NOARGS },
  { "do_exit", (PyCFunction) console_exit, METH_O, console_exit_doc },
  { "do_quit", (PyCFunction) console_exit, METH_O, console_exit_doc },
  { "do_debug", (PyCFunction) console_debug, METH_O, console_debug_doc },
  { "do_parse", (PyCFunction) console_parse, METH_O, console_parse_doc },
  { NULL }
};

static PyTypeObject Console_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ "Console",
  /* tp_basicsize      */ sizeof(consoleobject),
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) console_dealloc,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) 0,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ Py_TPFLAGS_DEFAULT,
  /* tp_doc            */ (char *) 0,
  /* tp_traverse       */ (traverseproc) 0,
  /* tp_clear          */ (inquiry) 0,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) console_methods,
  /* tp_members        */ (PyMemberDef *) 0,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ offsetof(consoleobject, dict),
  /* tp_init           */ (initproc) console_init,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) console_new,
  /* tp_free           */ 0,
};

static char console_doc[] = CONSOLE_NAME "\
()\n\
Starts an interactive parser console.";

static PyObject *module_console(PyObject *module, PyObject *args)
{
  PyObject *console, *result;

  args = PyTuple_New(0);
  if (args == NULL) return NULL;

  console = PyObject_Call((PyObject *) &Console_Type, args, NULL);
  if (console == NULL) {
    Py_DECREF(args);
    return NULL;
  }
  result = console_cmdloop((consoleobject *) console, args);
  Py_DECREF(args);
  Py_DECREF(console);
  return result;
}

static PyMethodDef module_methods[] = {
  { CONSOLE_NAME, module_console, METH_NOARGS, console_doc },
  { NULL }
};

static void import_modules(void);

#ifndef PyMODINIT_FUNC
#define PyMODINIT_FUNC DL_EXPORT(void)
#endif

PyMODINIT_FUNC MODULE_INITFUNC(void) {
  PyObject *import, *class, *item, *module;
  
  if (PyType_Ready(&Parser_Type) < 0) return;

  /* Setup the console type's base classes */
  import = PyImport_ImportModule("cmd");
  if (import == NULL) return;
  class = PyObject_GetAttrString(import, "Cmd");
  Py_DECREF(import);
  if (class == NULL) return;
  Console_Type.tp_base = &PyBaseObject_Type;
  Console_Type.tp_bases = Py_BuildValue("(ON)", class, &PyBaseObject_Type);
  if (Console_Type.tp_bases == NULL) return;
  if (PyType_Ready(&Console_Type) < 0) return;

  item = PyString_FromString(PARSER_NAME "> ");
  if (PyDict_SetItemString(Console_Type.tp_dict, "prompt", item) < 0) return;
  Py_DECREF(item);

  module = Py_InitModule(PARSER_NAME "c", module_methods);
  if (module == NULL) return;
  
  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, "new", (PyObject *) &Parser_Type);
  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, PARSER_NAME, (PyObject *) &Parser_Type);

  /* import the modules required for action routines */
  import_modules();
}

static PyObject *import_from(char *modulename, char *fromname) {
  PyObject *fromlist, *name, *module;

  fromlist = PyTuple_New(1);
  if (fromlist == NULL) return NULL;

  name = PyString_FromString(fromname);
  if (name == NULL) {
    Py_DECREF(fromlist);
    return NULL;
  }
  Py_INCREF(name);
  PyTuple_SET_ITEM(fromlist, 0, name);

  module = PyImport_ImportModuleEx(modulename, NULL, NULL, fromlist);
  Py_DECREF(fromlist);
  if (module == NULL) {
    Py_DECREF(name);
    return NULL;
  }

  fromlist = PyObject_GetAttr(module, name);
  Py_DECREF(module);
  Py_DECREF(name);
  return fromlist;
}

static void import_modules(void) {
  /* from Ft.Xml.XPointer import XPointer */
  XPointer = import_from("Ft.Xml.XPointer", "XPointer");
  if (XPointer == NULL) return;

}
