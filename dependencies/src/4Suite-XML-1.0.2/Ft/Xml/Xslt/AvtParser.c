/*
 * DO NOT EDIT THIS FILE!
 *
 * Parser generated by BisonGen on Wed Jan 11 14:35:58 2006.
 */

#include "Python.h"
#include "structmember.h"
#include "../src/common.h"

#define PROJECT_NAME "Ft.Xml.Xslt"
#define PARSER_NAME "AvtParser"
#define MODULE_INITFUNC initAvtParserc

/* modules required for action routines */
static PyObject *ParsedAbsoluteLocationPath;
static PyObject *ParsedRelativeLocationPath;
static PyObject *ParsedPredicateList;
static PyObject *ParsedStep;
static PyObject *ParsedAbbreviatedStep;
static PyObject *ParsedAxisSpecifier;
static PyObject *ParsedNodeTest;
static PyObject *ParsedNameTest;
static PyObject *PrincipalTypeTest;
static PyObject *LocalNameTest;
static PyObject *ParsedAbbreviatedAbsoluteLocationPath;
static PyObject *ParsedAbbreviatedRelativeLocationPath;
static PyObject *ParsedVariableReferenceExpr;
static PyObject *ParsedLiteralExpr;
static PyObject *ParsedNLiteralExpr;
static PyObject *ParsedFunctionCallExpr;
static PyObject *ParsedUnionExpr;
static PyObject *ParsedPathExpr;
static PyObject *ParsedFilterExpr;
static PyObject *ParsedOrExpr;
static PyObject *ParsedAndExpr;
static PyObject *ParsedEqualityExpr;
static PyObject *ParsedRelationalExpr;
static PyObject *ParsedAdditiveExpr;
static PyObject *ParsedMultiplicativeExpr;
static PyObject *ParsedUnaryExpr;

/* token definitions */
#define DOUBLE_DOT 257
#define DOUBLE_COLON 258
#define AT 259
#define LEFT_PAREN 260
#define LEFT_SQUARE 261
#define COMMA 262
#define LITERAL 263
#define NLITERAL 264
#define VARIABLE_REFERENCE 265
#define WILDCARD_NAME 266
#define MULTIPLY_OPERATOR 267
#define FUNCTION_NAME 268
#define DOUBLE_SLASH 269
#define NOT_EQUAL 270
#define LESS_THAN 271
#define GREATER_THAN 272
#define LESS_THAN_EQUAL 273
#define GREATER_THAN_EQUAL 274
#define OR 275
#define AND 276
#define DIV 277
#define MOD 278
#define COMMENT 279
#define TEXT 280
#define PROCESSING_INSTRUCTION 281
#define NODE 282
#define ANCESTOR 283
#define ANCESTOR_OR_SELF 284
#define ATTRIBUTE 285
#define CHILD 286
#define DESCENDANT 287
#define DESCENDANT_OR_SELF 288
#define FOLLOWING 289
#define FOLLOWING_SIBLING 290
#define NAMESPACE 291
#define PARENT 292
#define PRECEDING 293
#define PRECEDING_SIBLING 294
#define SELF 295
#define NODE_TYPE 296
#define AXIS_NAME 297
#define RELATIONAL_OP 298
#define EQUALITY_OP 299
#define AVT_LITERAL 300
#define AVT_ESCAPE 301

/* vector mapping lexer token numbers into internal token numbers */
static const int token_translations[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 51, 52, 2, 59, 57, 60, 55, 50, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 56, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 53, 2, 54, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 48, 58, 49, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 
33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47};

#define YYTRANSLATE(x) ((unsigned)(x) <= 301 ? token_translations[x] : 93)

/* vector of items of all rules. */
static const int rhs_tokens[] = {0, 62, 0, 0, 62, 63, 0, 62, 64, 0, 46, 0, 
47, 0, 48, 78, 49, 0, 67, 0, 66, 0, 50, 0, 50, 67, 0, 74, 0, 68, 0, 67, 
50, 68, 0, 75, 0, 70, 71, 0, 70, 71, 69, 0, 76, 0, 72, 0, 69, 72, 0, 43, 
4, 0, 77, 0, 12, 0, 42, 51, 52, 0, 42, 51, 9, 52, 0, 53, 73, 54, 0, 78, 
0, 15, 67, 0, 67, 15, 68, 0, 55, 0, 3, 0, 56, 0, 0, 86, 0, 11, 0, 51, 78, 
52, 0, 9, 0, 10, 0, 80, 0, 14, 51, 52, 0, 14, 51, 81, 52, 0, 82, 0, 81, 
57, 82, 0, 78, 0, 84, 0, 83, 58, 84, 0, 65, 0, 85, 0, 85, 50, 67, 0, 85, 
15, 67, 0, 79, 0, 79, 69, 0, 87, 0, 86, 21, 87, 0, 88, 0, 87, 22, 88, 0, 
89, 0, 88, 45, 89, 0, 90, 0, 89, 44, 90, 0, 91, 0, 90, 59, 91, 0, 90, 60, 
91, 0, 92, 0, 91, 13, 92, 0, 83, 0, 60, 83, 0};

/* vector of line numbers and filename of all rules */
static const char* const rule_info[] = {
    ": line 0",
    "Ft/Xml/Xslt/AvtParser.bgen: line 18",
    "Ft/Xml/Xslt/AvtParser.bgen: line 34",
    "Ft/Xml/Xslt/AvtParser.bgen: line 39",
    "Ft/Xml/Xslt/AvtParser.bgen: line 48",
    "Ft/Xml/Xslt/AvtParser.bgen: line 61",
    "Ft/Xml/Xslt/AvtParser.bgen: line 65",
    "Ft/Xml/Xslt/AvtParser.bgen: line 75",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 5",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 8",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 15",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 24",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 34",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 41",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 44",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 55",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 62",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 72",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 83",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 90",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 104",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 121",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 131",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 149",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 158",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 169",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 185",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 201",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 208",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 223",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 239",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 248",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 261",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 270",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 283",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 290",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 299",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 311",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 320",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 330",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 337",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 350",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 366",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 378",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 397",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 404",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 407",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 422",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 425",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 428",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 439",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 455",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 458",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 472",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 475",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 490",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 493",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 508",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 511",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 526",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 529",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 564",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 567",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 578",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 593",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 596",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 629",
    "Ft/Xml/XPath/XPathBase.bgen.frag: line 632",
};

/* vector of string-names indexed by token number */
static const char* const token_names[] = {
    "<EOF>",
    "error",
    "$undefined.",
    "DOUBLE_DOT",
    "DOUBLE_COLON",
    "AT",
    "LEFT_PAREN",
    "LEFT_SQUARE",
    "COMMA",
    "LITERAL",
    "NLITERAL",
    "VARIABLE_REFERENCE",
    "WILDCARD_NAME",
    "MULTIPLY_OPERATOR",
    "FUNCTION_NAME",
    "DOUBLE_SLASH",
    "NOT_EQUAL",
    "LESS_THAN",
    "GREATER_THAN",
    "LESS_THAN_EQUAL",
    "GREATER_THAN_EQUAL",
    "OR",
    "AND",
    "DIV",
    "MOD",
    "COMMENT",
    "TEXT",
    "PROCESSING_INSTRUCTION",
    "NODE",
    "ANCESTOR",
    "ANCESTOR_OR_SELF",
    "ATTRIBUTE",
    "CHILD",
    "DESCENDANT",
    "DESCENDANT_OR_SELF",
    "FOLLOWING",
    "FOLLOWING_SIBLING",
    "NAMESPACE",
    "PARENT",
    "PRECEDING",
    "PRECEDING_SIBLING",
    "SELF",
    "NODE_TYPE",
    "AXIS_NAME",
    "RELATIONAL_OP",
    "EQUALITY_OP",
    "AVT_LITERAL",
    "AVT_ESCAPE",
    "{",
    "}",
    "/",
    "(",
    ")",
    "[",
    "]",
    ".",
    "@",
    ",",
    "|",
    "+",
    "-",
    "start",
    "Avt",
    "PlainPart",
    "ParsedPart",
    "locationPath",
    "absoluteLocationPath",
    "relativeLocationPath",
    "step",
    "predicateList",
    "axisSpecifier",
    "nodeTest",
    "predicate",
    "predicateExpr",
    "abbreviatedAbsoluteLocationPath",
    "abbreviatedRelativeLocationPath",
    "abbreviatedStep",
    "abbreviatedAxisSpecifier",
    "expr",
    "primaryExpr",
    "functionCall",
    "argumentList",
    "argument",
    "unionExpr",
    "pathExpr",
    "filterExpr",
    "orExpr",
    "andExpr",
    "equalityExpr",
    "relationalExpr",
    "additiveExpr",
    "multiplicativeExpr",
    "unaryExpr",
    "0",
};

/* symbol number of symbol that rule derives. */
static const int derives[] = {0, 61, 62, 62, 62, 63, 63, 64, 65, 65, 66, 
66, 66, 67, 67, 67, 68, 68, 68, 69, 69, 70, 70, 71, 71, 71, 72, 73, 74, 
75, 76, 76, 77, 77, 78, 79, 79, 79, 79, 79, 80, 80, 81, 81, 82, 83, 83, 
84, 84, 84, 84, 85, 85, 86, 86, 87, 87, 88, 88, 89, 89, 90, 90, 90, 91, 
91, 92, 92};

/* number of symbols composing right hand side of rule. */
static const int rhs_size[] = {0, 1, 0, 2, 2, 1, 1, 3, 1, 1, 1, 2, 1, 1, 
3, 1, 2, 3, 1, 1, 2, 2, 1, 1, 3, 4, 3, 1, 2, 3, 1, 1, 1, 0, 1, 1, 3, 1, 
1, 1, 3, 4, 1, 3, 1, 1, 3, 1, 1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 
3, 3, 1, 3, 1, 2};

/* default rule to reduce with in state. 0 means the default is an error.
   indexed by state number */
static const int default_action[] = {2, 1, 5, 6, 33, 3, 4, 31, 37, 38, 35, 
0, 33, 0, 10, 33, 30, 32, 33, 47, 9, 8, 13, 0, 12, 15, 18, 22, 0, 51, 39, 
66, 45, 48, 34, 53, 55, 57, 59, 61, 64, 33, 28, 21, 11, 0, 67, 33, 33, 
23, 0, 16, 7, 33, 52, 19, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 40, 44, 
0, 42, 36, 29, 14, 0, 17, 0, 27, 20, 46, 50, 49, 54, 56, 58, 60, 62, 63, 
65, 41, 33, 0, 24, 26, 43, 25, 0, 0, 0};

/* default state to go to after a reduction of a rule.
   indexed by variable number (lhs token) */
static const int default_goto[] = {95, 1, 5, 6, 19, 20, 21, 22, 54, 23, 51, 
55, 75, 24, 25, 26, 27, 67, 29, 30, 68, 69, 31, 32, 33, 34, 35, 36, 37, 
38, 39, 40};

/* index in yytable of the portion describing state (indexed by state number)
   If the value in yytable is positive, we shift the token and go to that state.
   If the value is negative, it is minus a rule number to reduce by.
   If the value is zero, the default action from yydefact[s] is used. */
static const int action_idx[] = {-32768, 63, -32768, -32768, -3, -32768, 
-32768, -32768, -32768, -32768, -32768, -49, 0, 13, 46, -3, -32768, -32768, 
65, -32768, -32768, -11, -32768, -7, -32768, -32768, -32768, -32768, -34, 
-25, -32768, -27, -32768, -5, -2, 24, 5, 20, -36, 56, -32768, 11, -11, 
-32768, -11, 21, -27, 29, 29, -32768, 30, -25, -32768, 27, -25, -32768, 
83, 48, 48, 27, 27, 27, 27, 27, 27, 27, -32768, -32768, -39, -32768, -32768, 
-32768, -32768, -8, -25, 36, -32768, -32768, -32768, -11, -11, 24, 5, 20, 
-36, 56, 56, -32768, -32768, 27, 43, -32768, -32768, -32768, -32768, 96, 
99, -32768};

/* The index in yytable of the portion describing what to do after reducing a rule.
   The value from yytable is the state to go to. */
static const int goto_idx[] = {-32768, -32768, -32768, -32768, -32768, -32768, 
93, -14, 49, -32768, -32768, -45, -32768, -32768, -32768, -32768, -32768, 
12, -32768, -32768, -32768, 17, 94, 57, -32768, -32768, 55, 58, 61, 62, 
-4, 52};

/* A vector filled with portions for different uses.
   (using action_idx and goto_idx) */
static const int yytable[] = {7, 90, 41, 7, 47, 49, 8, 9, 10, 77, 57, 11, 
12, 88, 7, 52, 28, 43, 89, 59, 8, 9, 10, 63, 64, 11, 12, 45, 53, 77, 7, 
56, 7, 71, 72, 50, 8, 9, 10, 48, 13, 11, 12, 13, 91, 58, 60, 14, 15, 7, 
61, 7, 16, 17, 13, 16, 17, 18, -33, 85, 86, 14, 15, 66, 62, 76, 16, 17, 
7, 65, 13, 18, 13, 70, 8, 9, 10, 14, 15, 11, 12, 73, 16, 17, 16, 17, 7, 
18, -33, 13, 92, 13, 8, 9, 10, 94, 96, 11, 12, 97, 74, 16, 17, 16, 17, 
42, 93, 44, 13, 2, 3, 4, 46, 78, 81, 14, 15, 87, 82, 0, 16, 17, 83, 0, 
84, 0, 13, 0, 0, 0, 0, 0, 0, 14, 15, 0, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 79, 80};

/* a vector indexed in parallel with yytable.
   It indicates the bounds of the portion you are trying to examine. */
static const int yycheck[] = {3, 9, 51, 3, 15, 12, 9, 10, 11, 54, 15, 14, 
15, 52, 3, 49, 4, 4, 57, 21, 9, 10, 11, 59, 60, 14, 15, 15, 53, 74, 3, 
58, 3, 47, 48, 42, 9, 10, 11, 50, 43, 14, 15, 43, 52, 50, 22, 50, 51, 3, 
45, 3, 55, 56, 43, 55, 56, 60, 12, 63, 64, 50, 51, 52, 44, 53, 55, 56, 
3, 13, 43, 60, 43, 52, 9, 10, 11, 50, 51, 14, 15, 51, 55, 56, 55, 56, 3, 
60, 42, 43, 54, 43, 9, 10, 11, 52, 0, 14, 15, 0, 51, 55, 56, 55, 56, 12, 
89, 14, 43, 46, 47, 48, 18, 56, 59, 50, 51, 65, 60, -1, 55, 56, 61, -1, 
62, -1, 43, -1, -1, -1, -1, -1, -1, 50, 51, -1, -1, -1, 55, 56, -1, -1, 
-1, -1, -1, -1, -1, -1, -1, -1, 57, 58};

#define YYLAST 151
#define YYFINAL 97
#define YYFLAG -32768
#define YYNTBASE 61

#define LEXER_OP_FAILURE 0
#define LEXER_OP_SUCCESS 1
#define LEXER_OP_BOL 2
#define LEXER_OP_EOL 3
#define LEXER_OP_EOF 4
#define LEXER_OP_ANY 5
#define LEXER_OP_LITERAL 6
#define LEXER_OP_NOT_LITERAL 7
#define LEXER_OP_CHARSET 8
#define LEXER_OP_NOT_CHARSET 9
#define LEXER_OP_ASSERT 10
#define LEXER_OP_BRANCH 11
#define LEXER_OP_REPEAT 12
#define LEXER_OP_REPEAT_RANGE 13

#define LEXER_CHARSET_FAILURE 0
#define LEXER_CHARSET_LITERAL 1
#define LEXER_CHARSET_RANGE 2
#define LEXER_CHARSET_SMALL 3
#define LEXER_CHARSET_BIG 4

#define LEXER_INITIAL 1
#define LEXER_AVT 2
#define LEXER_OPERATOR 3
#define LEXER_START_STATE LEXER_AVT

static unsigned char lexer_charsets[57][32] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x26, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07,
    0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x7F, 0xFE, 0xFD, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x0F, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x31, 0xFC },
  { 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xF8,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
    0xFF, 0x7F, 0x7F, 0x54, 0xFD, 0xFF, 0x0F, 0x00 },
  { 0xFE, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xDF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x9F, 0x19, 0xFF, 0xFF, 0xFF, 0xCF, 0x3F, 0x03 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02,
    0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x07, 0x07, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0x07, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7C,
    0xFF, 0x7F, 0x2F, 0x00, 0x60, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x00, 0xFF,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x03,
    0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x00 },
  { 0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E,
    0x00, 0x00, 0x1C, 0x00, 0xE0, 0xAF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 },
  { 0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xCD, 0x23, 0x00, 0x00, 0x00, 0xB0,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xBF, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x03,
    0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00 },
  { 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x0D, 0x00, 0x3F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x96, 0x25, 0xF0, 0xFE, 0xAE, 0x6C, 0x0D, 0x20,
    0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF,
    0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00 },
  { 0xED, 0xDA, 0x07, 0x00, 0x00, 0x00, 0x00, 0x50, 0x01, 0x50, 0x31, 0x82,
    0xAB, 0x62, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xC9, 0x80, 0xF5,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03 },
  { 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA,
    0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F,
    0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 0xDC, 0x1F },
  { 0x00, 0x00, 0x00, 0x00, 0x40, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07 },
  { 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x80, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFB, 0xFF, 0xFF, 0xBB,
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x07, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0xFF, 0x9F, 0x3D, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xFF, 0x3F, 0x1E, 0x00,
    0x0C, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
    0x9F, 0x39, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00 },
  { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x87, 0x39, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
    0xBF, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x8F, 0x39, 0xC0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
    0xC7, 0x3D, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xDF, 0x3D, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
    0xDF, 0x3D, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xCF, 0x3D, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x07, 0x80, 0x7F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x1B,
    0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xA0, 0xC2, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xDF, 0x0F, 0xBF, 0xFE, 0xFF, 0x3F, 0xFE, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x1F, 0x02, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70 },
};

static unsigned char lexer_blockmaps[5][256] = {
  { 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0B, 0x0C, 0x0D, 0x0E,
    0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x15, 0x16, 0x0B, 0x17, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x18, 0x19, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
  { 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x1C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1D, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
  { 0x1F, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x20, 0x0B, 0x0B, 0x21, 0x21, 0x22,
    0x21, 0x23, 0x24, 0x25, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
  { 0x0B, 0x0B, 0x0B, 0x26, 0x27, 0x28, 0x29, 0x0B, 0x0B, 0x2A, 0x2B, 0x2C,
    0x2D, 0x2E, 0x2F, 0x30, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x31, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x32, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
  { 0x33, 0x0B, 0x34, 0x35, 0x0B, 0x0B, 0x36, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x37, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x38, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
};

static const Py_UCS4 lexer_INITIAL_pattern_0[] = { 6, 125, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_1[] = { 8, 4, 3, 2, 0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_2[] = { 6, 58, 6, 58, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_3[] = { 6, 47, 6, 47, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_4[] = { 11, 4, 6, 61, 1, 6, 
  6, 33, 6, 61, 1, 0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_5[] = { 11, 7, 8, 4, 3, 3, 0, 
  1, 6, 6, 60, 6, 61, 1, 6, 6, 62, 6, 61, 1, 0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_6[] = { 11, 10, 6, 110, 6, 111, 
  6, 100, 6, 101, 1, 10, 6, 116, 6, 101, 6, 120, 6, 116, 1, 16, 6, 99, 
  6, 111, 6, 109, 6, 109, 6, 101, 6, 110, 6, 116, 1, 46, 6, 112, 6, 114, 
  6, 111, 6, 99, 6, 101, 6, 115, 6, 115, 6, 105, 6, 110, 6, 103, 6, 45, 
  6, 105, 6, 110, 6, 115, 6, 116, 6, 114, 6, 117, 6, 99, 6, 116, 6, 105, 
  6, 111, 6, 110, 1, 0, 10, 13, 12, 8, 0, 8, 4, 3, 1, 0, 1, 6, 40, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_7[] = { 11, 4, 6, 95, 1, 18, 
  11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 12, 51, 0, 11, 
  7, 8, 4, 3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 
  1, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 7, 8, 4, 4, 4, 0, 
  1, 0, 1, 10, 15, 12, 8, 0, 8, 4, 3, 1, 0, 1, 6, 58, 6, 58, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_8[] = { 11, 12, 6, 39, 12, 5, 
  0, 7, 39, 1, 6, 39, 1, 12, 6, 34, 12, 5, 0, 7, 34, 1, 6, 34, 1, 0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_9[] = { 11, 32, 12, 8, 1, 8, 
  4, 4, 2, 0, 1, 13, 20, 0, 1, 6, 46, 13, 13, 0, 1, 12, 8, 1, 8, 4, 4, 
  2, 0, 1, 1, 1, 1, 13, 6, 46, 12, 8, 1, 8, 4, 4, 2, 0, 1, 1, 0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_10[] = { 6, 36, 13, 82, 0, 1, 
  11, 4, 6, 95, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 
  1, 0, 12, 51, 0, 11, 7, 8, 4, 3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 
  1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 
  1, 7, 8, 4, 4, 4, 0, 1, 0, 1, 6, 58, 1, 11, 4, 6, 95, 1, 18, 11, 7, 8, 
  4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 12, 51, 0, 11, 7, 8, 4, 
  3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 
  7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 7, 8, 4, 4, 4, 0, 1, 0, 1, 
  1 };

static const Py_UCS4 lexer_INITIAL_pattern_11[] = { 13, 82, 0, 1, 11, 4, 
  6, 95, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 
  12, 51, 0, 11, 7, 8, 4, 3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 
  8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 7, 
  8, 4, 4, 4, 0, 1, 0, 1, 6, 58, 1, 11, 4, 6, 95, 1, 18, 11, 7, 8, 4, 4, 
  0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 12, 51, 0, 11, 7, 8, 4, 3, 30, 
  0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 
  4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 7, 8, 4, 4, 4, 0, 1, 0, 1, 10, 13, 12, 
  8, 0, 8, 4, 3, 1, 0, 1, 6, 40, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_12[] = { 11, 4, 6, 42, 1, 82, 
  11, 4, 6, 95, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 
  1, 0, 12, 51, 0, 11, 7, 8, 4, 3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 
  1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 
  1, 7, 8, 4, 4, 4, 0, 1, 0, 1, 6, 58, 6, 42, 1, 161, 13, 82, 0, 1, 11, 
  4, 6, 95, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 
  0, 12, 51, 0, 11, 7, 8, 4, 3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 
  7, 8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 
  7, 8, 4, 4, 4, 0, 1, 0, 1, 6, 58, 1, 11, 4, 6, 95, 1, 18, 11, 7, 8, 4, 
  4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 12, 51, 0, 11, 7, 8, 4, 3, 
  30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 7, 
  8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 7, 8, 4, 4, 4, 0, 1, 0, 1, 1, 
  0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_13[] = { 6, 46, 6, 46, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_14[] = { 6, 46, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_15[] = { 12, 8, 1, 8, 4, 3, 
  1, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_16[] = { 5, 1 };

static const Py_UCS4 *lexer_INITIAL_patterns[] = {
  lexer_INITIAL_pattern_0,
  lexer_INITIAL_pattern_1,
  lexer_INITIAL_pattern_2,
  lexer_INITIAL_pattern_3,
  lexer_INITIAL_pattern_4,
  lexer_INITIAL_pattern_5,
  lexer_INITIAL_pattern_6,
  lexer_INITIAL_pattern_7,
  lexer_INITIAL_pattern_8,
  lexer_INITIAL_pattern_9,
  lexer_INITIAL_pattern_10,
  lexer_INITIAL_pattern_11,
  lexer_INITIAL_pattern_12,
  lexer_INITIAL_pattern_13,
  lexer_INITIAL_pattern_14,
  lexer_INITIAL_pattern_15,
  lexer_INITIAL_pattern_16,
  NULL
};

static const Py_UCS4 lexer_AVT_pattern_0[] = { 11, 9, 13, 6, 2, 2, 6, 123, 
  1, 1, 9, 13, 6, 2, 2, 6, 125, 1, 1, 0, 1 };

static const Py_UCS4 lexer_AVT_pattern_1[] = { 12, 8, 1, 9, 4, 3, 0, 0, 
  1, 1 };

static const Py_UCS4 lexer_AVT_pattern_2[] = { 5, 1 };

static const Py_UCS4 *lexer_AVT_patterns[] = {
  lexer_AVT_pattern_0,
  lexer_AVT_pattern_1,
  lexer_AVT_pattern_2,
  NULL
};

static const Py_UCS4 lexer_OPERATOR_pattern_0[] = { 6, 111, 6, 114, 1 };

static const Py_UCS4 lexer_OPERATOR_pattern_1[] = { 6, 97, 6, 110, 6, 100, 
  1 };

static const Py_UCS4 lexer_OPERATOR_pattern_2[] = { 11, 4, 6, 42, 1, 8, 
  6, 109, 6, 111, 6, 100, 1, 8, 6, 100, 6, 105, 6, 118, 1, 0, 1 };

static const Py_UCS4 lexer_OPERATOR_pattern_3[] = { 12, 8, 1, 8, 4, 3, 
  1, 0, 1, 1 };

static const Py_UCS4 lexer_OPERATOR_pattern_4[] = { 5, 1 };

static const Py_UCS4 *lexer_OPERATOR_patterns[] = {
  lexer_OPERATOR_pattern_0,
  lexer_OPERATOR_pattern_1,
  lexer_OPERATOR_pattern_2,
  lexer_OPERATOR_pattern_3,
  lexer_OPERATOR_pattern_4,
  NULL
};

static const Py_UCS4 **lexer_patterns[] = {
  NULL,
  lexer_INITIAL_patterns,
  lexer_AVT_patterns,
  lexer_OPERATOR_patterns
};

static const int lexer_INITIAL_actions[] = { 8, 9, 10, 11, 12, 13, 14, 
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24 };

static const int lexer_AVT_actions[] = { 0, 1, 2 };

static const int lexer_OPERATOR_actions[] = { 3, 4, 5, 6, 7 };

static const int *lexer_actions[] = {
  NULL,
  lexer_INITIAL_actions,
  lexer_AVT_actions,
  lexer_OPERATOR_actions
};

#if PY_VERSION_HEX < 0x02020000 || !defined(Py_USING_UNICODE)
#error "Python 2.2+ with unicode support required"
#endif

/* Static Definitions */
#define YYEMPTY -2
#define YYERROR -1
#define YYEOF 0
#define YYINITDEPTH 1000
#define LEXER_INITIAL_BACKTRACKS 20

/* Parsing objects */
typedef struct {
  PyObject_HEAD
  int verbose;
  PyObject *dict;
} parserobject;

typedef struct {
  PyObject *text;
  int last;
  int state;
  Py_UNICODE *end;
  Py_UNICODE *position;

  /* backtracking stack */
  int backtracks;
  Py_UNICODE **positions;
  int allocated;
} lexerobject;

static int parser_yylex(parserobject *, lexerobject *, PyObject **);
static lexerobject *lexer_new(PyObject *);
static void lexer_free(lexerobject *);
static int lexer_save_position(lexerobject *);
static Py_UNICODE *lexer_restore_position(lexerobject *);
static int lexer_charset(parserobject *, Py_UCS4 *, Py_UCS4, int);
static int lexer_match(parserobject *, lexerobject *, Py_UCS4 *);
static void lexer_error(lexerobject *);

static char *unicode_escape(Py_UNICODE *, int);
static PyObject *report_error(int state, PyObject *lval, lexerobject *lexer);
static void print_reduce(int ruleno);
static void print_state_stack(int *stack, int *end);

/* Parser Methods */

/* Attempt to use C99 variable argument macros for improved error detection
 * (just in case). 
 */
#ifdef __STDC__ /* C99 conformance macro */
#define TRACE(...) if (self->verbose > 0) PySys_WriteStderr(__VA_ARGS__)
#define REGEX_TRACE(...) if (self->verbose > 1) PySys_WriteStderr(__VA_ARGS__)
#else
#define TRACE if (self->verbose > 0) PySys_WriteStderr
#define REGEX_TRACE if (self->verbose > 1) PySys_WriteStderr
#endif

static char parse_doc[] = "\
parse(string) -> object\n\
Converts the given string to a parse tree and return the top-most\n\
element of the tree.";

static PyObject* parser_parse(register parserobject *self, PyObject *text)
{
  register int yystate;
  register int yyn;

  PyObject *yylval = NULL;
  PyObject *yyval = NULL;

  int state_stack[YYINITDEPTH];
  int *state_ptr;
  PyObject *value_stack[YYINITDEPTH];
  PyObject **value_ptr;

  int yylen;
  int yychar = YYEMPTY;         /* cause a token to be read */
  int yychar1 = 0;

  lexerobject *lexer;

  lexer = lexer_new(text);
  if (lexer == NULL)
    return NULL;

  TRACE("Starting parse\n");

  /* Initialize stack pointers
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized. */
  state_ptr = state_stack - 1;
  value_ptr = value_stack;

  yystate = 0;

  while (1) {
    /* Push a new state, which is found in yystate. */
    /* In all cases, when you get here, the value and location stacks
       have just been pushed.  So pushing a state here evens the stacks. */
    *++state_ptr = yystate;

    TRACE("Entering state %d\n", yystate);

    /* Do appropriate processing given the current state. */
    /* Read a lookahead token if we need one and don't already have one. */

    /* First try to decide what to do without reference to lookahead token. */
    yyn = action_idx[yystate];
    if (yyn == YYFLAG) {
      yyn = default_action[yystate];
      if (yyn == 0) {
        return report_error(yystate, yylval, lexer);
      }

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 2: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 34
   * Avt:
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 3: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 39
   * Avt: Avt PlainPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 4: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 48
   * Avt: Avt ParsedPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 65
   * PlainPart: AVT_ESCAPE
   */
  yyval = PyUnicode_FromUnicode(PyUnicode_AS_UNICODE(value_ptr[1]), 1);
  if (self->verbose) {
    fprintf(stderr, "--PlainPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 7: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 75
   * ParsedPart: '{' expr '}'
   */
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--ParsedPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 10: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 15
   * absoluteLocationPath: '/'
   */
  yyval = PyObject_CallFunction(ParsedAbsoluteLocationPath, "O", Py_None);
  if (self->verbose) {
    fprintf(stderr, "--absoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 11: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 24
   * absoluteLocationPath: '/' relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedAbsoluteLocationPath, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--absoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 44
   * relativeLocationPath: relativeLocationPath '/' step
   */
  yyval = PyObject_CallFunction(ParsedRelativeLocationPath, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--relativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 16: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 62
   * step: axisSpecifier nodeTest
   */
  yyval = PyObject_CallFunction(ParsedStep, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 17: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 72
   * step: axisSpecifier nodeTest predicateList
   */
  yyval = PyObject_CallFunction(ParsedStep, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 19: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 90
   * predicateList: predicate
   */
  PyObject *pred_list = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(pred_list, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  yyval = PyObject_CallFunction(ParsedPredicateList, "O", pred_list);
  Py_DECREF(pred_list);
  if (self->verbose) {
    fprintf(stderr, "--predicateList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 20: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 104
   * predicateList: predicateList predicate
   */
  PyObject_CallMethod(value_ptr[1], "append", "O", value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--predicateList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 21: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 121
   * axisSpecifier: AXIS_NAME DOUBLE_COLON
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--axisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 23: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 149
   * nodeTest: WILDCARD_NAME
   */
  yyval = PyObject_CallFunction(ParsedNameTest, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 24: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 158
   * nodeTest: NODE_TYPE '(' ')'
   */
  yyval = PyObject_CallFunction(ParsedNodeTest, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 25: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 169
   * nodeTest: NODE_TYPE '(' LITERAL ')'
   */
  yyval = PyObject_CallFunction(ParsedNodeTest, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 26: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 185
   * predicate: '[' predicateExpr ']'
   */
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--predicate(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 28: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 208
   * abbreviatedAbsoluteLocationPath: DOUBLE_SLASH relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedAbsoluteLocationPath,
                             "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 29: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 223
   * abbreviatedRelativeLocationPath: relativeLocationPath DOUBLE_SLASH step
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedRelativeLocationPath,
                             "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedRelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 30: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 239
   * abbreviatedStep: '.'
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedStep, "i", 0);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedStep(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 31: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 248
   * abbreviatedStep: DOUBLE_DOT
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedStep, "i", 1);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedStep(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 32: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 261
   * abbreviatedAxisSpecifier: '@'
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "s", "attribute");
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 33: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 270
   * abbreviatedAxisSpecifier:
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "s", "child");
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAxisSpecifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 35: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 290
   * primaryExpr: VARIABLE_REFERENCE
   */
  yyval = PyObject_CallFunction(ParsedVariableReferenceExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 36: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 299
   * primaryExpr: '(' expr ')'
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 37: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 311
   * primaryExpr: LITERAL
   */
  yyval = PyObject_CallFunction(ParsedLiteralExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 38: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 320
   * primaryExpr: NLITERAL
   */
  yyval = PyObject_CallFunction(ParsedNLiteralExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 40: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 337
   * functionCall: FUNCTION_NAME '(' ')'
   */
  PyObject *arg_list = PyList_New(0);
  yyval = PyObject_CallFunction(ParsedFunctionCallExpr, "OO", value_ptr[1], arg_list);
  Py_DECREF(arg_list);
  if (self->verbose) {
    fprintf(stderr, "--functionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 41: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 350
   * functionCall: FUNCTION_NAME '(' argumentList ')'
   */
  yyval = PyObject_CallFunction(ParsedFunctionCallExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--functionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 42: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 366
   * argumentList: argument
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--argumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 43: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 378
   * argumentList: argumentList ',' argument
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--argumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 46: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 407
   * unionExpr: unionExpr '|' pathExpr
   */
  yyval = PyObject_CallFunction(ParsedUnionExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--unionExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 428
   * pathExpr: filterExpr '/' relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedPathExpr, "iOO", 0, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--pathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 50: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 439
   * pathExpr: filterExpr DOUBLE_SLASH relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedPathExpr, "iOO", 1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--pathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 52: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 458
   * filterExpr: primaryExpr predicateList
   */
  yyval = PyObject_CallFunction(ParsedFilterExpr, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--filterExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 54: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 475
   * orExpr: orExpr OR andExpr
   */
  yyval = PyObject_CallFunction(ParsedOrExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--orExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 493
   * andExpr: andExpr AND equalityExpr
   */
  yyval = PyObject_CallFunction(ParsedAndExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--andExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 58: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 511
   * equalityExpr: equalityExpr EQUALITY_OP relationalExpr
   */
  yyval = PyObject_CallFunction(ParsedEqualityExpr, "OOO", value_ptr[2], value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--equalityExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 529
   * relationalExpr: relationalExpr RELATIONAL_OP additiveExpr
   */
  char *op = PyString_AsString(value_ptr[2]);
  if (op[0] == '<') {
    if (op[1] == '=') {
      /* less than or equal to */
      yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 1, value_ptr[1], value_ptr[3]);
    } else {
      /* less than */
      yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 0, value_ptr[1], value_ptr[3]);
    }
  } else if (op[1] == '=') {
    /* greater than or equal to */
    yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 3, value_ptr[1], value_ptr[3]);
  } else {
    /* greater than */
    yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 2, value_ptr[1], value_ptr[3]);
  }
  if (self->verbose) {
    fprintf(stderr, "--relationalExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 62: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 567
   * additiveExpr: additiveExpr '+' multiplicativeExpr
   */
  yyval = PyObject_CallFunction(ParsedAdditiveExpr, "iOO", 1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--additiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 63: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 578
   * additiveExpr: additiveExpr '-' multiplicativeExpr
   */
  yyval = PyObject_CallFunction(ParsedAdditiveExpr, "iOO", -1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--additiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 65: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 596
   * multiplicativeExpr: multiplicativeExpr MULTIPLY_OPERATOR unaryExpr
   */
  char *op = PyString_AsString(value_ptr[2]);
  switch (*op) {
    case '*': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 0, value_ptr[1], value_ptr[3]);
      break;
    }
    case 'd': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 1, value_ptr[1], value_ptr[3]);
      break;
    }
    case 'm': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 2, value_ptr[1], value_ptr[3]);
      break;
    }
  }
  if (self->verbose) {
    fprintf(stderr, "--multiplicativeExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 67: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 632
   * unaryExpr: '-' unionExpr
   */
  yyval = PyObject_CallFunction(ParsedUnaryExpr, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--unaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);


      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    } /* if (yyn == YYFLAG) */

    /* Not known => get a lookahead token if don't already have one. */

    /* yychar is either YYEMPTY, YYEOF or a valid token in external form */
    if (yychar == YYEMPTY) {
      TRACE("Reading a token: ");
      yychar = parser_yylex(self, lexer, &yylval);
    }

    /* Convert token to internal form (in yychar1) for indexing tables with */

    if (yychar <= 0) {
      if (yychar == YYERROR) {
        lexer_free(lexer);
        return NULL;
      }
      /* This means end-of-input. */
      yychar1 = 0;
      TRACE("Now at end of input.\n");
    } else {
      yychar1 = YYTRANSLATE(yychar);
      TRACE("Next token is %d (%s)\n", yychar, token_names[yychar1]);
      yyn += yychar1;
    }
    if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1) {
      /* comes here after end of input */
      yyn = default_action[yystate];
      if (yyn == 0) {
        return report_error(yystate, NULL, lexer);
      }

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 2: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 34
   * Avt:
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 3: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 39
   * Avt: Avt PlainPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 4: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 48
   * Avt: Avt ParsedPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 65
   * PlainPart: AVT_ESCAPE
   */
  yyval = PyUnicode_FromUnicode(PyUnicode_AS_UNICODE(value_ptr[1]), 1);
  if (self->verbose) {
    fprintf(stderr, "--PlainPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 7: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 75
   * ParsedPart: '{' expr '}'
   */
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--ParsedPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 10: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 15
   * absoluteLocationPath: '/'
   */
  yyval = PyObject_CallFunction(ParsedAbsoluteLocationPath, "O", Py_None);
  if (self->verbose) {
    fprintf(stderr, "--absoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 11: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 24
   * absoluteLocationPath: '/' relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedAbsoluteLocationPath, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--absoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 44
   * relativeLocationPath: relativeLocationPath '/' step
   */
  yyval = PyObject_CallFunction(ParsedRelativeLocationPath, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--relativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 16: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 62
   * step: axisSpecifier nodeTest
   */
  yyval = PyObject_CallFunction(ParsedStep, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 17: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 72
   * step: axisSpecifier nodeTest predicateList
   */
  yyval = PyObject_CallFunction(ParsedStep, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 19: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 90
   * predicateList: predicate
   */
  PyObject *pred_list = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(pred_list, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  yyval = PyObject_CallFunction(ParsedPredicateList, "O", pred_list);
  Py_DECREF(pred_list);
  if (self->verbose) {
    fprintf(stderr, "--predicateList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 20: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 104
   * predicateList: predicateList predicate
   */
  PyObject_CallMethod(value_ptr[1], "append", "O", value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--predicateList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 21: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 121
   * axisSpecifier: AXIS_NAME DOUBLE_COLON
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--axisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 23: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 149
   * nodeTest: WILDCARD_NAME
   */
  yyval = PyObject_CallFunction(ParsedNameTest, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 24: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 158
   * nodeTest: NODE_TYPE '(' ')'
   */
  yyval = PyObject_CallFunction(ParsedNodeTest, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 25: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 169
   * nodeTest: NODE_TYPE '(' LITERAL ')'
   */
  yyval = PyObject_CallFunction(ParsedNodeTest, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 26: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 185
   * predicate: '[' predicateExpr ']'
   */
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--predicate(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 28: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 208
   * abbreviatedAbsoluteLocationPath: DOUBLE_SLASH relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedAbsoluteLocationPath,
                             "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 29: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 223
   * abbreviatedRelativeLocationPath: relativeLocationPath DOUBLE_SLASH step
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedRelativeLocationPath,
                             "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedRelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 30: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 239
   * abbreviatedStep: '.'
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedStep, "i", 0);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedStep(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 31: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 248
   * abbreviatedStep: DOUBLE_DOT
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedStep, "i", 1);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedStep(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 32: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 261
   * abbreviatedAxisSpecifier: '@'
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "s", "attribute");
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 33: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 270
   * abbreviatedAxisSpecifier:
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "s", "child");
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAxisSpecifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 35: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 290
   * primaryExpr: VARIABLE_REFERENCE
   */
  yyval = PyObject_CallFunction(ParsedVariableReferenceExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 36: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 299
   * primaryExpr: '(' expr ')'
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 37: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 311
   * primaryExpr: LITERAL
   */
  yyval = PyObject_CallFunction(ParsedLiteralExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 38: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 320
   * primaryExpr: NLITERAL
   */
  yyval = PyObject_CallFunction(ParsedNLiteralExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 40: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 337
   * functionCall: FUNCTION_NAME '(' ')'
   */
  PyObject *arg_list = PyList_New(0);
  yyval = PyObject_CallFunction(ParsedFunctionCallExpr, "OO", value_ptr[1], arg_list);
  Py_DECREF(arg_list);
  if (self->verbose) {
    fprintf(stderr, "--functionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 41: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 350
   * functionCall: FUNCTION_NAME '(' argumentList ')'
   */
  yyval = PyObject_CallFunction(ParsedFunctionCallExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--functionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 42: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 366
   * argumentList: argument
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--argumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 43: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 378
   * argumentList: argumentList ',' argument
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--argumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 46: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 407
   * unionExpr: unionExpr '|' pathExpr
   */
  yyval = PyObject_CallFunction(ParsedUnionExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--unionExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 428
   * pathExpr: filterExpr '/' relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedPathExpr, "iOO", 0, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--pathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 50: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 439
   * pathExpr: filterExpr DOUBLE_SLASH relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedPathExpr, "iOO", 1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--pathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 52: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 458
   * filterExpr: primaryExpr predicateList
   */
  yyval = PyObject_CallFunction(ParsedFilterExpr, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--filterExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 54: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 475
   * orExpr: orExpr OR andExpr
   */
  yyval = PyObject_CallFunction(ParsedOrExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--orExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 493
   * andExpr: andExpr AND equalityExpr
   */
  yyval = PyObject_CallFunction(ParsedAndExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--andExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 58: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 511
   * equalityExpr: equalityExpr EQUALITY_OP relationalExpr
   */
  yyval = PyObject_CallFunction(ParsedEqualityExpr, "OOO", value_ptr[2], value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--equalityExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 529
   * relationalExpr: relationalExpr RELATIONAL_OP additiveExpr
   */
  char *op = PyString_AsString(value_ptr[2]);
  if (op[0] == '<') {
    if (op[1] == '=') {
      /* less than or equal to */
      yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 1, value_ptr[1], value_ptr[3]);
    } else {
      /* less than */
      yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 0, value_ptr[1], value_ptr[3]);
    }
  } else if (op[1] == '=') {
    /* greater than or equal to */
    yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 3, value_ptr[1], value_ptr[3]);
  } else {
    /* greater than */
    yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 2, value_ptr[1], value_ptr[3]);
  }
  if (self->verbose) {
    fprintf(stderr, "--relationalExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 62: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 567
   * additiveExpr: additiveExpr '+' multiplicativeExpr
   */
  yyval = PyObject_CallFunction(ParsedAdditiveExpr, "iOO", 1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--additiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 63: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 578
   * additiveExpr: additiveExpr '-' multiplicativeExpr
   */
  yyval = PyObject_CallFunction(ParsedAdditiveExpr, "iOO", -1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--additiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 65: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 596
   * multiplicativeExpr: multiplicativeExpr MULTIPLY_OPERATOR unaryExpr
   */
  char *op = PyString_AsString(value_ptr[2]);
  switch (*op) {
    case '*': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 0, value_ptr[1], value_ptr[3]);
      break;
    }
    case 'd': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 1, value_ptr[1], value_ptr[3]);
      break;
    }
    case 'm': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 2, value_ptr[1], value_ptr[3]);
      break;
    }
  }
  if (self->verbose) {
    fprintf(stderr, "--multiplicativeExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 67: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 632
   * unaryExpr: '-' unionExpr
   */
  yyval = PyObject_CallFunction(ParsedUnaryExpr, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--unaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);

      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    }

    yyn = yytable[yyn];

    /* yyn is what to do for this token type in this state.
       Negative => reduce, -yyn is rule number.
       Positive => shift, yyn is new state.
         New state is final state => don't bother to shift
         just return success.
       0, or max negative number => error. */

    if (yyn > YYFLAG && yyn < 0) {
      yyn = -yyn;

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 2: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 34
   * Avt:
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 3: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 39
   * Avt: Avt PlainPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 4: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 48
   * Avt: Avt ParsedPart
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Avt(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 6: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 65
   * PlainPart: AVT_ESCAPE
   */
  yyval = PyUnicode_FromUnicode(PyUnicode_AS_UNICODE(value_ptr[1]), 1);
  if (self->verbose) {
    fprintf(stderr, "--PlainPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 7: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 75
   * ParsedPart: '{' expr '}'
   */
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--ParsedPart(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 10: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 15
   * absoluteLocationPath: '/'
   */
  yyval = PyObject_CallFunction(ParsedAbsoluteLocationPath, "O", Py_None);
  if (self->verbose) {
    fprintf(stderr, "--absoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 11: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 24
   * absoluteLocationPath: '/' relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedAbsoluteLocationPath, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--absoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 14: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 44
   * relativeLocationPath: relativeLocationPath '/' step
   */
  yyval = PyObject_CallFunction(ParsedRelativeLocationPath, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--relativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 16: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 62
   * step: axisSpecifier nodeTest
   */
  yyval = PyObject_CallFunction(ParsedStep, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 17: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 72
   * step: axisSpecifier nodeTest predicateList
   */
  yyval = PyObject_CallFunction(ParsedStep, "OOO", value_ptr[1], value_ptr[2], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--step(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 19: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 90
   * predicateList: predicate
   */
  PyObject *pred_list = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(pred_list, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  yyval = PyObject_CallFunction(ParsedPredicateList, "O", pred_list);
  Py_DECREF(pred_list);
  if (self->verbose) {
    fprintf(stderr, "--predicateList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 20: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 104
   * predicateList: predicateList predicate
   */
  PyObject_CallMethod(value_ptr[1], "append", "O", value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--predicateList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 21: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 121
   * axisSpecifier: AXIS_NAME DOUBLE_COLON
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--axisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 23: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 149
   * nodeTest: WILDCARD_NAME
   */
  yyval = PyObject_CallFunction(ParsedNameTest, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 24: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 158
   * nodeTest: NODE_TYPE '(' ')'
   */
  yyval = PyObject_CallFunction(ParsedNodeTest, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 25: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 169
   * nodeTest: NODE_TYPE '(' LITERAL ')'
   */
  yyval = PyObject_CallFunction(ParsedNodeTest, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--nodeTest(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 26: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 185
   * predicate: '[' predicateExpr ']'
   */
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--predicate(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 28: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 208
   * abbreviatedAbsoluteLocationPath: DOUBLE_SLASH relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedAbsoluteLocationPath,
                             "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAbsoluteLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 29: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 223
   * abbreviatedRelativeLocationPath: relativeLocationPath DOUBLE_SLASH step
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedRelativeLocationPath,
                             "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedRelativeLocationPath(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 30: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 239
   * abbreviatedStep: '.'
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedStep, "i", 0);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedStep(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 31: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 248
   * abbreviatedStep: DOUBLE_DOT
   */
  yyval = PyObject_CallFunction(ParsedAbbreviatedStep, "i", 1);
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedStep(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 32: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 261
   * abbreviatedAxisSpecifier: '@'
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "s", "attribute");
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAxisSpecifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 33: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 270
   * abbreviatedAxisSpecifier:
   */
  yyval = PyObject_CallFunction(ParsedAxisSpecifier, "s", "child");
  if (self->verbose) {
    fprintf(stderr, "--abbreviatedAxisSpecifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 35: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 290
   * primaryExpr: VARIABLE_REFERENCE
   */
  yyval = PyObject_CallFunction(ParsedVariableReferenceExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 36: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 299
   * primaryExpr: '(' expr ')'
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 37: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 311
   * primaryExpr: LITERAL
   */
  yyval = PyObject_CallFunction(ParsedLiteralExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 38: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 320
   * primaryExpr: NLITERAL
   */
  yyval = PyObject_CallFunction(ParsedNLiteralExpr, "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--primaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 40: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 337
   * functionCall: FUNCTION_NAME '(' ')'
   */
  PyObject *arg_list = PyList_New(0);
  yyval = PyObject_CallFunction(ParsedFunctionCallExpr, "OO", value_ptr[1], arg_list);
  Py_DECREF(arg_list);
  if (self->verbose) {
    fprintf(stderr, "--functionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 41: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 350
   * functionCall: FUNCTION_NAME '(' argumentList ')'
   */
  yyval = PyObject_CallFunction(ParsedFunctionCallExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--functionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 42: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 366
   * argumentList: argument
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--argumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 43: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 378
   * argumentList: argumentList ',' argument
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--argumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 46: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 407
   * unionExpr: unionExpr '|' pathExpr
   */
  yyval = PyObject_CallFunction(ParsedUnionExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--unionExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 428
   * pathExpr: filterExpr '/' relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedPathExpr, "iOO", 0, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--pathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 50: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 439
   * pathExpr: filterExpr DOUBLE_SLASH relativeLocationPath
   */
  yyval = PyObject_CallFunction(ParsedPathExpr, "iOO", 1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--pathExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 52: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 458
   * filterExpr: primaryExpr predicateList
   */
  yyval = PyObject_CallFunction(ParsedFilterExpr, "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--filterExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 54: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 475
   * orExpr: orExpr OR andExpr
   */
  yyval = PyObject_CallFunction(ParsedOrExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--orExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 493
   * andExpr: andExpr AND equalityExpr
   */
  yyval = PyObject_CallFunction(ParsedAndExpr, "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--andExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 58: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 511
   * equalityExpr: equalityExpr EQUALITY_OP relationalExpr
   */
  yyval = PyObject_CallFunction(ParsedEqualityExpr, "OOO", value_ptr[2], value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--equalityExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 529
   * relationalExpr: relationalExpr RELATIONAL_OP additiveExpr
   */
  char *op = PyString_AsString(value_ptr[2]);
  if (op[0] == '<') {
    if (op[1] == '=') {
      /* less than or equal to */
      yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 1, value_ptr[1], value_ptr[3]);
    } else {
      /* less than */
      yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 0, value_ptr[1], value_ptr[3]);
    }
  } else if (op[1] == '=') {
    /* greater than or equal to */
    yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 3, value_ptr[1], value_ptr[3]);
  } else {
    /* greater than */
    yyval = PyObject_CallFunction(ParsedRelationalExpr, "lOO", 2, value_ptr[1], value_ptr[3]);
  }
  if (self->verbose) {
    fprintf(stderr, "--relationalExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 62: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 567
   * additiveExpr: additiveExpr '+' multiplicativeExpr
   */
  yyval = PyObject_CallFunction(ParsedAdditiveExpr, "iOO", 1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--additiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 63: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 578
   * additiveExpr: additiveExpr '-' multiplicativeExpr
   */
  yyval = PyObject_CallFunction(ParsedAdditiveExpr, "iOO", -1, value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--additiveExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 65: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 596
   * multiplicativeExpr: multiplicativeExpr MULTIPLY_OPERATOR unaryExpr
   */
  char *op = PyString_AsString(value_ptr[2]);
  switch (*op) {
    case '*': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 0, value_ptr[1], value_ptr[3]);
      break;
    }
    case 'd': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 1, value_ptr[1], value_ptr[3]);
      break;
    }
    case 'm': {
      yyval = PyObject_CallFunction(ParsedMultiplicativeExpr, "lOO", 2, value_ptr[1], value_ptr[3]);
      break;
    }
  }
  if (self->verbose) {
    fprintf(stderr, "--multiplicativeExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 67: {
  /* from Ft/Xml/XPath/XPathBase.bgen.frag, line 632
   * unaryExpr: '-' unionExpr
   */
  yyval = PyObject_CallFunction(ParsedUnaryExpr, "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--unaryExpr(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);

      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    } else if (yyn == YYFINAL) {
      /* Hooray!  Process complete. */
      lexer_free(lexer);
      return value_ptr[-1];
    } else if (yyn <= 0) {
      /* Now it is either 0 or YYFLAG */
      return report_error(yystate, yylval, lexer);
    }

    /* Shift the lookahead token. */

    TRACE("Shifting token %d (%s), ", yychar, token_names[yychar1]);

    if (yychar != YYEOF) {
      yychar = YYEMPTY;
    }

    *++value_ptr = yylval;

    yystate = yyn;
    continue;
  }

  /* should never get here */
  Py_INCREF(Py_None);
  lexer_free(lexer);
  return Py_None;
}

/** lexer routines ****************************************************/

static lexerobject *lexer_new(PyObject *text)
{
  lexerobject *lexer;

  lexer = PyMem_New(lexerobject, 1);
  if (lexer == NULL) {
    PyErr_NoMemory();
    return NULL;
  }

  /* attempt to coerce given object to unicode using default rules */
  lexer->text = PyUnicode_FromObject(text);
  if (lexer->text == NULL) {
    PyMem_Free(lexer);
    return NULL;
  }
  lexer->position = PyUnicode_AS_UNICODE(lexer->text);
  lexer->end = lexer->position + PyUnicode_GET_SIZE(lexer->text);
  lexer->state = LEXER_START_STATE;

  /* create initial backtracking stack */
  lexer->positions = PyMem_New(Py_UNICODE *, LEXER_INITIAL_BACKTRACKS);
  if (lexer->positions == NULL) {
    PyErr_NoMemory();
    Py_DECREF(lexer->text);
    PyMem_Free(lexer);
    return NULL;
  }
  lexer->allocated = LEXER_INITIAL_BACKTRACKS;
  lexer->backtracks = 0;
  return lexer;
}

static void lexer_free(lexerobject *lexer)
{
  PyMem_Free(lexer->positions);
  Py_DECREF(lexer->text);
  PyMem_Free(lexer);
}

static int lexer_save_position(lexerobject *lexer) {
  Py_UNICODE **positions;
  size_t new_allocated;
  int allocated, newsize;

  /* Bypass realloc() when a previous overallocation is large enough
     to accommodate the newsize.
  */
  newsize = lexer->backtracks + 1;
  allocated = lexer->allocated;
  positions = lexer->positions;
  if (newsize >= allocated) {
    /* This over-allocates proportional to the list size, making room
     * for additional growth.  The over-allocation is mild, but is
     * enough to give linear-time amortized behavior over a long
     * sequence of appends() in the presence of a poorly-performing
     * system realloc().
     * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
     */
    new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6) + newsize;
    if (PyMem_Resize(positions, Py_UNICODE *, new_allocated) == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    lexer->allocated = new_allocated;
    lexer->positions = positions;
  }
  lexer->positions[lexer->backtracks] = lexer->position;
  lexer->backtracks = newsize;
  return 0;
}

static Py_UNICODE *lexer_restore_position(lexerobject *lexer) {
  assert(lexer->backtracks > 0);
  lexer->position = lexer->positions[--lexer->backtracks];
  return lexer->position;
}

static int lexer_charset(parserobject *self, Py_UCS4 *set, Py_UCS4 ch,
			 int ok)
{
  unsigned char *charset;

  /* check if character is a member of the given set */
  /* Note, the tests are stored sorted to allow for quick exits */

  for (;;) {
    switch (*set++) {

    case LEXER_CHARSET_LITERAL:
      /* <LITERAL> <code> */
      REGEX_TRACE("CHARSET_LITERAL, %d == %d\n", ch, set[0]);
      if (ch < set[0])
        return !ok;
      else if ((Py_UCS4)ch == set[0])
        return ok;
      set++;
      break;

    case LEXER_CHARSET_RANGE:
      /* <RANGE> <lower> <upper> */
      REGEX_TRACE("CHARSET_RANGE, %d <= %d <= %d\n", set[0], ch, set[1]);
      if (ch < set[0])
        return !ok;
      else if (ch <= set[1])
        return ok;
      set += 2;
      break;

    case LEXER_CHARSET_SMALL:
      /* <SMALL> <charset index> */
      REGEX_TRACE("CHARSET_SMALL, index=%d\n", set[0]);
      charset = lexer_charsets[*set++];
      if (ch < 256 && (charset[ch >> 3] & (1 << (ch & 7))))
        return ok;
      break;

    case LEXER_CHARSET_BIG:
      /* <BIG> <blockmap index> */
      REGEX_TRACE("CHARSET_BIG, index=%d\n", set[0]);
      charset = lexer_charsets[lexer_blockmaps[*set++][ch >> 8]];
      if (ch < 65536 && charset[(ch & 255) >> 3] & (1 << (ch & 7)))
        return ok;
      break;

    case LEXER_CHARSET_FAILURE:
      /* nothing matched in charset */
      REGEX_TRACE("CHARSET_FAILURE\n");
      return !ok;

    default:
      REGEX_TRACE("**INTERNAL CHARSET ERROR**\n");
      return -1;
    }
  }
}

/* return values:
   1 -> sucessful match,
   0 -> no match,
   -1 -> error,
*/

#ifdef Py_UNICODE_WIDE
#define GET_CHAR_AND_ADVANCE() ch = *ptr++;
#else
#define GET_CHAR_AND_ADVANCE()                                          \
  if ((0xD800 <= ptr[0] && ptr[0] <= 0xDBFF) &&                         \
      (0xDC00 <= ptr[1] && ptr[1] <= 0xDFFF)) {                         \
    ch = (((ptr[0] & 0x03FF) << 10) | (ptr[1] & 0x03FF)) + 0x00010000;  \
    ptr += 2;                                                           \
  } else {                                                              \
    ch = *ptr++;                                                        \
  }
#endif  
    
static int lexer_match(parserobject *self, lexerobject *lexer, 
		       Py_UCS4 *pattern)
{
  Py_UNICODE *ptr = lexer->position;
  Py_UNICODE *end;
  Py_UCS4 ch;
  int i, count;

  REGEX_TRACE("LEXER_MATCH, position %" YY_FORMAT_SIZE_T "d\n",
              lexer->position - PyUnicode_AS_UNICODE(lexer->text));

  while (1) {
    switch (*pattern++) {

    case LEXER_OP_FAILURE:
      /* immediate failure */
      REGEX_TRACE("OP_FAILURE\n");
      return 0;

    case LEXER_OP_SUCCESS:
      /* end of pattern */
      REGEX_TRACE("OP_SUCCESS\n");
      lexer->position = ptr;
      return 1;
        
    case LEXER_OP_BOL:
      /* beginning of line */
      /* <BOL> */
      REGEX_TRACE("OP_BOL\n");
      if (ptr == PyUnicode_AS_UNICODE(lexer->text) || ptr[-1] == '\n') 
        break;
      return 0;

    case LEXER_OP_EOL:
      /* end of line */
      /* <EOL> */
      REGEX_TRACE("OP_EOL\n");
      if (ptr >= lexer->end || ptr[0] == '\n') break;
      return 0;
            
    case LEXER_OP_EOF:
      /* end of file */
      /* <EOF> */
      REGEX_TRACE("OP_EOF\n");
      if (ptr >= lexer->end) break;
      return 0;

    case LEXER_OP_ANY:
      /* match anything (except a newline) */
      /* <ANY> */
      REGEX_TRACE("OP_ANY\n");
      if (ptr >= lexer->end || ptr[0] == '\n')
        return 0;
      ptr++;
      break;

    case LEXER_OP_LITERAL:
      /* match literal character */
      /* <LITERAL> <code> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_LITERAL, %d == %d\n", ch, pattern[0]);
      if (ch != pattern[0])
        return 0;
      pattern++;
      break;

    case LEXER_OP_NOT_LITERAL:
      /* match anything that is not literal character */
      /* <NOT_LITERAL> <code> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_NOT_LITERAL, %d != %d\n", ch, pattern[0]);
      if (ch == pattern[0])
        return 0;
      pattern++;
      break;

    case LEXER_OP_CHARSET:
      /* match set member */
      /* <CHARSET> <skip> <set> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_CHARSET, skip %d\n", pattern[0]);
      i = lexer_charset(self, pattern + 1, ch, 1);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;
            
    case LEXER_OP_NOT_CHARSET:
      /* match set non-member */
      /* <NOT_CHARSET> <skip> <set> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_NOT_CHARSET, skip %d\n", pattern[0]);
      i = lexer_charset(self, pattern + 1, ch, 0);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;
            
    case LEXER_OP_ASSERT:
      /* lookahead assertion */
      /* <ASSERT> <skip> <pattern> */
      REGEX_TRACE("OP_ASSERT, skip %d\n", pattern[0]);
      lexer->position = ptr;
      i = lexer_match(self, lexer, pattern + 1);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;

    case LEXER_OP_BRANCH:
      /* alternation */
      /* <BRANCH> <skip0> <code0> <skip1> <code1> ... <NULL> */

      end = NULL;
      count = 0;
      while (pattern[0]) {
        /* reset start position each time through */
	REGEX_TRACE("OP_BRANCH %d, skip %d\n", count++, pattern[0]);
        lexer->position = ptr;
        
        i = lexer_match(self, lexer, pattern + 1);
        if (i < 0)
          return i;
        else if (i && lexer->position > end) 
          /* successful match which is longer than the current best matched */
          end = lexer->position;
        
        /* advance to the next pattern */
        pattern += pattern[0];
      }

      /* advance pattern past NULL */
      pattern++;

      /* advance to the best matching position if there was a match */
      if (end) {
        lexer->position = ptr = end;
        break;
      }

      return 0;

    case LEXER_OP_REPEAT:
      /* repetition */
      /* <REPEAT> <skip> <1=min> item */
      {
        Py_UCS4 *item = pattern + 2;
        Py_UCS4 *next = pattern + pattern[0];
        int minimum = pattern[1];
        int backtracks;

        lexer->position = ptr;
        for (count = 0, i = 1; i == 1 && count < minimum; count++) {
          REGEX_TRACE("OP_REPEAT<stage 1>, min %d, now %d\n",
                      minimum, count);
          i = lexer_match(self, lexer, item);
        }
        
        /* either internal error or failed minimum matches */
        if (i <= 0) 
          return i;

        backtracks = lexer->backtracks;

        /* match as many items as possible */
        for (; i == 1; count++) {
          REGEX_TRACE("OP_REPEAT<stage 2>, now %d\n", count);
          if (lexer_save_position(lexer) < 0)
            return -1;
          i = lexer_match(self, lexer, item);
        }
          
        if (i < 0) {
          /* internal error */
          lexer->backtracks = backtracks;
          return i;
        }
          
        /* backtracking assert of tail match until success */
        do {
          REGEX_TRACE("OP_REPEAT<stage 3>, now %d\n", count);
          /* update position to previous successful match */
          ptr = lexer_restore_position(lexer);
          if (ptr == NULL)
            return -1;
          i = lexer_match(self, lexer, next);
        } while (i == 0 && --count > minimum);

        /* discard remaining backtrack positions */
        lexer->backtracks = backtracks;

        if (i <= 0) {
          return i;
        }
        pattern = next;
      }
      break;

    case LEXER_OP_REPEAT_RANGE:
      /* repetition */
      /* <REPEAT_RANGE> <skip> <1=min> <2=max> item */
      {
        Py_UCS4 *item = pattern + 3;
        Py_UCS4 *next = pattern + pattern[0];
        int minimum = pattern[1];
        int maximum = pattern[2];
        int backtracks;

        lexer->position = ptr;
        for (count = 0, i = 1; i == 1 && count < minimum; count++) {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 1>, min %d, now %d\n",
                      minimum, count);
          i = lexer_match(self, lexer, item);
        }
        
        /* either internal error or failed minimum matches */
        if (i <= 0) 
          return i;

        backtracks = lexer->backtracks;

        /* consume up to 'maximum' matches */
        for (; i == 1 && count < maximum; count++) {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 2>, max %d, now %d\n",
                      maximum, count);
          if (lexer_save_position(lexer) < 0)
            return -1;
          i = lexer_match(self, lexer, item);
        }

        if (i < 0) {
          /* internal error */
          lexer->backtracks = backtracks;
          return i;
        }

        /* maximum matches reached, update saved position */
        if (i == 1)
          ptr = lexer->position;

        /* backtracking assert of tail match until success */
        do {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 3>, now %d\n", count);
          if (i == 0) {
            /* update position to last successful match */
            ptr = lexer_restore_position(lexer);
            if (ptr == NULL)
              return -1;
          }
          i = lexer_match(self, lexer, next);
        } while (i == 0 && --count > minimum);

        /* discard remaining backtrack positions */
        lexer->backtracks = backtracks;

        if (i <= 0)
          return i;

        pattern = next;
      }
      break;

    default:
      REGEX_TRACE("**INTERNAL MATCH ERROR**\n");
      return -1;
    }
  }
}

static int parser_yylex(parserobject *self, lexerobject *lexer,
			PyObject **yylval)
{
  int yychar = YYEMPTY;
  int yylen;
  Py_UNICODE *yytext = lexer->position;
  
  while (yytext < lexer->end && yychar == YYEMPTY) {
    Py_UNICODE *best_end = NULL;
    int yyaccept = 0;
    int i;
    Py_UCS4 **patterns = (Py_UCS4 **)lexer_patterns[lexer->state];
    const int *actions = lexer_actions[lexer->state];

    REGEX_TRACE("Using patterns from lexer state %d\n", lexer->state);
    for (i = 0; patterns[i]; i++) {
      int matched;
      /* reset position each time through */
      lexer->position = yytext;

      REGEX_TRACE("--- pattern %d...\n", i);
      matched = lexer_match(self, lexer, patterns[i]);
      
      if (matched > 0 && lexer->position > best_end) {
        /* successful match which is longer than the current best matched */
        best_end = lexer->position;
        yyaccept = i;
      } else if (matched < 0) {
        /* internal error */
	REGEX_TRACE("--- pattern %d internal error\n", i);
        PyErr_SetString(PyExc_RuntimeError,
                        "internal error in regular expression engine");
        return -1;
      }
      REGEX_TRACE("--- pattern %d %s\n", i, matched ? "success" : "failed");
    }
      
    if (best_end == NULL) {
      /* no matches */
      lexer->position = yytext;
      lexer_error(lexer);
      return -1;
    }

    lexer->position = best_end;
    yylen = best_end - yytext;

    /* get the action block for this match */
    switch (actions[yyaccept]) {
case 0: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 98 */
  TRACE("using rule from Ft/Xml/Xslt/AvtParser.bgen[98], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = AVT_ESCAPE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 1: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 102 */
  TRACE("using rule from Ft/Xml/Xslt/AvtParser.bgen[102], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = AVT_LITERAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 2: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 106 */
  TRACE("using rule from Ft/Xml/Xslt/AvtParser.bgen[106], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = (int)*yytext;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 3: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 8 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[8], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = OR;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 4: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 13 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[13], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = AND;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 5: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 18 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[18], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = MULTIPLY_OPERATOR;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 6: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 24 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[24], ");
  /* skip over the matched text */
  yytext = lexer->position;
  break;
}
case 7: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 26 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[26], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  break;
}
case 8: {
  /* from Ft/Xml/Xslt/AvtParser.bgen, line 112 */
  TRACE("using rule from Ft/Xml/Xslt/AvtParser.bgen[112], ");
  lexer->state = LEXER_AVT;
  TRACE("switching to start condition AVT, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = '}';

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 9: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 31 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[31], ");
  lexer->state = LEXER_OPERATOR;
  TRACE("switching to start condition OPERATOR, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = (int)*yytext;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 10: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 36 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[36], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOUBLE_COLON;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 11: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 41 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[41], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOUBLE_SLASH;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 12: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 46 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[46], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = EQUALITY_OP;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 13: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 51 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[51], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = RELATIONAL_OP;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 14: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 57 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[57], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = NODE_TYPE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 15: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 62 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[62], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = AXIS_NAME;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 16: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 67 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[67], ");
  lexer->state = LEXER_OPERATOR;
  TRACE("switching to start condition OPERATOR, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LITERAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 17: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 72 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[72], ");
  lexer->state = LEXER_OPERATOR;
  TRACE("switching to start condition OPERATOR, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = NLITERAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 18: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 77 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[77], ");
  lexer->state = LEXER_OPERATOR;
  TRACE("switching to start condition OPERATOR, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = VARIABLE_REFERENCE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 19: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 82 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[82], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = FUNCTION_NAME;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 20: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 86 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[86], ");
  lexer->state = LEXER_OPERATOR;
  TRACE("switching to start condition OPERATOR, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = WILDCARD_NAME;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 21: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 91 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[91], ");
  lexer->state = LEXER_OPERATOR;
  TRACE("switching to start condition OPERATOR, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOUBLE_DOT;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 22: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 97 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[97], ");
  lexer->state = LEXER_OPERATOR;
  TRACE("switching to start condition OPERATOR, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = (int)*yytext;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 23: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 103 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[103], ");
  /* skip over the matched text */
  yytext = lexer->position;
  break;
}
case 24: {
  /* from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag, line 105 */
  TRACE("using rule from Ft/Xml/XPath/XPathLexerPatterns.bgen.frag[105], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = (int)*yytext;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
    }
  }

  if (yychar == YYEMPTY) {
    /* Reached end of input */
    yychar = YYEOF;
  }

  return yychar;
}

/** Type Object *******************************************************/

static int parser_traverse(parserobject *self, visitproc visit, void *arg)
{
  int rv;

  if (self->dict) {
    rv = visit(self->dict, arg);
    if (rv != 0) return rv;
  }
  return 0;
}

static int parser_clear(parserobject *self)
{
  PyObject *tmp;

  if (self->dict) {
    tmp = self->dict;
    self->dict = NULL;
    Py_DECREF(tmp);
  }
  return 0;
}

static void parser_dealloc(parserobject *self)
{
  parser_clear(self);
  self->ob_type->tp_free((PyObject *) self);
}

static int parser_init(parserobject *self, PyObject *args, PyObject *kwds)
{
  PyObject *debug=NULL;
  static char *kwlist[] = { "debug", NULL };

  if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:" PARSER_NAME, kwlist,
                                   &debug))
    return -1;

  if (debug) {
    self->verbose = PyObject_IsTrue(debug);
  }

  return 0;
}

static PyObject *parser_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  parserobject *self;

  self = (parserobject *) type->tp_alloc(type, 0);
  if (self != NULL) {
    self->dict = PyDict_New();
    if (self->dict == NULL) {
      Py_DECREF(self);
      return NULL;
    }
    self->verbose = 0;
  }
  return (PyObject *) self;
}

static PyMethodDef parser_methods[] = {
  { "parse", (PyCFunction) parser_parse, METH_O, parse_doc },
  { NULL, NULL }
};

static PyMemberDef parser_members[] = {
  { "debug", T_INT, offsetof(parserobject, verbose) },
  { NULL }
};

static char parser_doc[] = PARSER_NAME "\
([debug]) -> parser\n\
Create a new parser object.\n\
\n\
The optional debug argument, when true, enables the builtin trace facility.\n\
The trace facility uses stderr to display each step taken by the parser.";

static PyTypeObject Parser_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ PROJECT_NAME "." PARSER_NAME,
  /* tp_basicsize      */ sizeof(parserobject),
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) parser_dealloc,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) 0,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
  /* tp_doc            */ (char *) parser_doc,
  /* tp_traverse       */ (traverseproc) parser_traverse,
  /* tp_clear          */ (inquiry) parser_clear,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) parser_methods,
  /* tp_members        */ (PyMemberDef *) parser_members,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ offsetof(parserobject, dict),
  /* tp_init           */ (initproc) parser_init,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) parser_new,
  /* tp_free           */ 0,
};

/* Helper functions */

/* caller is responsible for releasing the memory */
static char *unicode_escape(Py_UNICODE *s, int len)
{
  static const char *hexdigit = "0123456789ABCDEF";
  char *repr, *p;
  int i, size;

  /* Do one pass to get the repr'ed size */
  size = 1;  /* zero terminator */
  for (i = 0; i < len; i++) {
#ifdef Py_UNICODE_WIDE
    if (s[i] >= 65536) size += 10;  /* \UHHHHHHHH */
    else
#endif
    if (s[i] >= 256) size += 6;  /* \uHHHH */
    else if (s[i] == 9 || s[i] == 10 || s[i] == 13) size += 2;  /* \t \n \r */
    else if (s[i] < 32 || s[i] >= 128) size += 4;  /* \xHH */
    else size++; /* printable US-ASCII */
  }
  
  repr = p = PyMem_New(char, size + 1);
  if (repr == NULL) return NULL;

  while (len-- > 0) {
    Py_UNICODE ch = *s++;
#ifdef Py_UNICODE_WIDE
    /* Map 32-bit characters to '\Uxxxxxxxx' */
    if (ch >= 65536) {
      *p++ = '\\';
      *p++ = 'U';
      *p++ = hexdigit[(ch >> 28) & 0xf];
      *p++ = hexdigit[(ch >> 24) & 0xf];
      *p++ = hexdigit[(ch >> 20) & 0xf];
      *p++ = hexdigit[(ch >> 16) & 0xf];
      *p++ = hexdigit[(ch >> 12) & 0xf];
      *p++ = hexdigit[(ch >> 8) & 0xf];
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Map 16-bit characters to '\uxxxx' */
    else 
#endif
    if (ch >= 256) {
      *p++ = '\\';
      *p++ = 'u';
      *p++ = hexdigit[(ch >> 12) & 0xf];
      *p++ = hexdigit[(ch >> 8) & 0xf];
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Map special whitespace to '\t', \n', '\r' */
    else if (ch == 9) {
      *p++ = '\\';
      *p++ = 't';
    }
    else if (ch == 10) {
      *p++ = '\\';
      *p++ = 'n';
    }
    else if (ch == 13) {
      *p++ = '\\';
      *p++ = 'r';
    }
    /* Map non-printable US ASCII to '\xhh' */
    else if (ch < 32 || ch >= 128) {
      *p++ = '\\';
      *p++ = 'x';
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Copy everything else as-is */
    else
      *p++ = (char) ch;
  }

  *p = '\0';

  return repr;
}

static void calculate_position(lexerobject *lexer, int *line, int *column) {
  /* Determine line and column numbers */
  Py_UNICODE *p;

  *line = 1;
  *column = 1;

  for (p = PyUnicode_AS_UNICODE(lexer->text); p < lexer->end; p++) {
    if ((char)*p == '\n') {
      *line += 1;
      *column = 1;
    } else {
      *column += 1;
    }
  }
}

static const char error_format_str[] = "parse error at line %d, column %d: matched '%s'";
static const char error_format_eof_str[] = "parse error at line %d, column %d: reached end-of-input";

static PyObject *report_error(int state, PyObject* lval, lexerobject *lexer) {
  int line, column;
  int ruleno = action_idx[state];
  char *matched = NULL;

  if (lval) {
    matched = unicode_escape(PyUnicode_AS_UNICODE(lval), 
                             PyUnicode_GET_SIZE(lval));
    if (matched == NULL) return NULL;
  }

  calculate_position(lexer, &line, &column);
  Py_DECREF(lexer->text);

  if (ruleno > YYFLAG && ruleno < YYLAST) {
    /* There are expected tokens */
    int x, count;
    int size = 60;  /* Initial format string */
    char *msg;

    /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
    for (x = (ruleno < 0 ? -ruleno : 0);
         x < (sizeof(token_names) / sizeof(char *)); x++) {
      if (yycheck[x + ruleno] == x) {
        size += strlen(token_names[x]) + 15;
      }
    }

    msg = PyMem_New(char, size);
    if (msg == NULL) {
      PyMem_Del(matched);
      return NULL;
    }

    if (lval) {
      strcpy(msg, error_format_str);
    } else {
      strcpy(msg, error_format_eof_str);
    }

    count = 0;
    for (x = (ruleno < 0 ? -ruleno : 0);
         x < (sizeof(token_names) / sizeof(char *)); x++) {
      if (yycheck[x + ruleno] == x) {
        strcat(msg, count == 0 ? ", expecting '" : " or '");
        strcat(msg, token_names[x]);
        strcat(msg, "'");
        count++;
      }
    }
    if (matched) {
      PyErr_Format(PyExc_SyntaxError, msg, line, column, matched);
    } else {
      PyErr_Format(PyExc_SyntaxError, msg, line, column);
    }
    PyMem_Del(msg);
  } else {
    if (matched) {
      PyErr_Format(PyExc_SyntaxError, error_format_str, line, column, matched);
    } else {
      PyErr_Format(PyExc_SyntaxError, error_format_eof_str, line, column);
    }
  }

  if (matched) {
    PyMem_Del(matched);
  }

  return NULL;
}

static const char lexer_error_str[] = "lexical error at line %d, column %d: no action found for '%s'";

static void lexer_error(lexerobject *lexer)
{
  int line, column;
  char *repr = unicode_escape(lexer->position, (lexer->end - lexer->position));
  if (repr == NULL) return;

  calculate_position(lexer, &line, &column);

  PyErr_Format(PyExc_SyntaxError, lexer_error_str, line, column, repr);

  PyMem_Del(repr);
  return;
}

static void print_reduce(int ruleno) {
  int count;
  const int *token;

  PySys_WriteStderr("Reducing via rule %d (%s), ", ruleno, rule_info[ruleno]);
  /* print the symbols being reduced and their result. */

  count = ruleno;
  token = rhs_tokens;
  while (--count) while (*++token);

  while (*++token) {
    PySys_WriteStderr("%s ", token_names[*token]);
  }
  PySys_WriteStderr("-> %s\n", token_names[derives[ruleno]]);
}

static void print_state_stack(int *stack, int *end) {
  int *curr = stack;

  PySys_WriteStderr("state stack now");
  while (curr <= end) {
    PySys_WriteStderr(" %d", *curr++);
  }
  PySys_WriteStderr("\n");
}

/** Interactive parser ************************************************/

#define CONSOLE_NAME PARSER_NAME "Console"

typedef struct {
  PyObject_HEAD
  parserobject *parser;
  PyObject *dict;
} consoleobject;

static PyObject *console_new(PyTypeObject *type, PyObject *args,
			     PyObject *kwds)
{
  consoleobject *self;

  self = (consoleobject *) type->tp_alloc(type, 0);
  if (self != NULL) {
    PyObject *args = Py_BuildValue("(i)", 1);
    if (args == NULL) {
      Py_DECREF(self);
      return NULL;
    }
    self->parser = (parserobject *) parser_new(&Parser_Type, args, NULL);
    Py_DECREF(args);
    if (self->parser == NULL) {
      Py_DECREF(self);
      return NULL;
    }
  }
  return (PyObject *) self;
}

static int console_init(consoleobject *self, PyObject *args, PyObject *kwds)
{
  PyObject *bases, *base, *result;
  int size, i;

  if (!PyArg_ParseTuple(args, ":" CONSOLE_NAME)) return -1;

  bases = self->ob_type->tp_bases;
  size = PyTuple_GET_SIZE(bases);
  for (i = 0; i < size; i++) {
    base = PyTuple_GET_ITEM(bases, i);
    result = PyObject_CallMethod(base, "__init__", "O", (PyObject *) self);
    if (result == NULL) return -1;
    Py_DECREF(result);
  }
  return 0;
}

static void console_dealloc(consoleobject *self)
{
  Py_XDECREF(self->parser);
  self->ob_type->tp_free((PyObject *) self);
}

static PyObject *console_cmdloop(consoleobject *self, PyObject *args)
{
  PyObject *result=NULL, *builtins=NULL, *readline=NULL, *old_completer=NULL;
  int stop;

  builtins = PyImport_ImportModule("__builtin__");
  if (builtins == NULL) goto exit;

  readline = PyImport_ImportModule("readline");
  if (readline == NULL) {
    if (!PyErr_ExceptionMatches(PyExc_ImportError)) goto exit;
    PyErr_Clear();
  } else {
#if PY_VERSION_HEX > 0x02030000
    /* old_completer = readline.get_completer() */
    old_completer = PyObject_CallMethod(readline, "get_completer", NULL);
    if (old_completer == NULL) goto exit;
#endif
    /* readline.set_completer(self.complete) */
    result = PyObject_GetAttrString((PyObject *) self, "complete");
    if (result == NULL) goto exit;
    result = PyObject_CallMethod(readline, "set_completer", "N", result);
    if (result == NULL) goto exit;
    Py_DECREF(result);
    /* readline.parse_and_bind("tab: complete") */
    result = PyObject_CallMethod(readline, "parse_and_bind", "s",
				 "tab: complete");
    if (result == NULL) goto exit;
    Py_DECREF(result);
  }

  stop = 0;
  do {
    result = PyObject_GetAttrString((PyObject *) self, "prompt");
    if (result == NULL) goto finally;
    result = PyObject_CallMethod(builtins, "raw_input", "N", result);
    if (result == NULL) {
      if (PyErr_ExceptionMatches(PyExc_EOFError) ||
	  PyErr_ExceptionMatches(PyExc_KeyboardInterrupt)) {
	PyErr_Clear();
	PySys_WriteStdout("\n");
	Py_INCREF(Py_None);
	result = Py_None;
      }
      goto finally;
    }
    result = PyObject_CallMethod((PyObject *) self, "onecmd", "N", result);
    if (result == NULL) goto finally;
    stop = PyObject_IsTrue(result);
    Py_DECREF(result);
  } while (!stop);

  Py_INCREF(Py_None);
  result = Py_None;

 finally:
#if PY_VERSION_HEX > 0x02030000
  if (readline != NULL && old_completer != NULL) {
    PyObject *rv;
    rv = PyObject_CallMethod(readline, "set_completer", "O", old_completer);
    if (rv == NULL) {
      Py_XDECREF(result);
      result = rv;
    } else {
      Py_DECREF(rv);
    }
  }
#endif
 exit:
  Py_XDECREF(old_completer);
  Py_XDECREF(readline);
  Py_XDECREF(builtins);
  return result;
}

static PyObject *console_emptyline(consoleobject *self, PyObject *noarg)
{
  Py_INCREF(Py_None);
  return Py_None;
}

static char console_exit_doc[] = "terminate the console";

static PyObject *console_exit(consoleobject *self, PyObject *arg)
{
  Py_INCREF(Py_True);
  return Py_True;
}

static char console_debug_doc[] = "sets or displays the debug level";

static PyObject *console_debug(consoleobject *self, PyObject *arg)
{
  PyObject *verbose;

  if (PyObject_IsTrue(arg)) {
    if ((verbose = PyNumber_Int(arg)) == NULL) {
      if (PyErr_ExceptionMatches(PyExc_ValueError)) {
	PyErr_Clear();
	PySys_WriteStdout("usage: debug <level>\n");
	Py_INCREF(Py_None);
	return Py_None;
      }
      return NULL;
    }
    self->parser->verbose = PyInt_AsLong(verbose);
    Py_DECREF(verbose);
  }
  PySys_WriteStdout("debug level is %d\n", self->parser->verbose);
  Py_INCREF(Py_None);
  return Py_None;
}

static char console_parse_doc[] = "parses an expression";

static PyObject *console_parse(consoleobject *self, PyObject *arg)
{
  PyObject *result, *value;

  result = parser_parse(self->parser, arg);
  if (result == NULL) {
    PyObject *exc, *tb;
    if (!PyErr_ExceptionMatches(PyExc_SyntaxError)) return NULL;
    PyErr_Fetch(&exc, &value, &tb);
    if (value && value != Py_None) {
      result = PyObject_Str(value);
    }
    Py_XDECREF(exc);
    Py_XDECREF(value);
    Py_XDECREF(tb);
    if (result == NULL) return NULL;
  }

  value = PyObject_Str(result);
  Py_DECREF(result);
  if (value == NULL) return NULL;

  PySys_WriteStdout("%s\n", PyString_AsString(value));
  Py_DECREF(value);

  Py_INCREF(Py_None);
  return Py_None;
}

static PyMethodDef console_methods[] = {
  { "cmdloop", (PyCFunction) console_cmdloop, METH_O },
  { "emptyline", (PyCFunction) console_emptyline, METH_NOARGS },
  { "do_exit", (PyCFunction) console_exit, METH_O, console_exit_doc },
  { "do_quit", (PyCFunction) console_exit, METH_O, console_exit_doc },
  { "do_debug", (PyCFunction) console_debug, METH_O, console_debug_doc },
  { "do_parse", (PyCFunction) console_parse, METH_O, console_parse_doc },
  { NULL }
};

static PyTypeObject Console_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ "Console",
  /* tp_basicsize      */ sizeof(consoleobject),
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) console_dealloc,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) 0,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ Py_TPFLAGS_DEFAULT,
  /* tp_doc            */ (char *) 0,
  /* tp_traverse       */ (traverseproc) 0,
  /* tp_clear          */ (inquiry) 0,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) console_methods,
  /* tp_members        */ (PyMemberDef *) 0,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ offsetof(consoleobject, dict),
  /* tp_init           */ (initproc) console_init,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) console_new,
  /* tp_free           */ 0,
};

static char console_doc[] = CONSOLE_NAME "\
()\n\
Starts an interactive parser console.";

static PyObject *module_console(PyObject *module, PyObject *args)
{
  PyObject *console, *result;

  args = PyTuple_New(0);
  if (args == NULL) return NULL;

  console = PyObject_Call((PyObject *) &Console_Type, args, NULL);
  if (console == NULL) {
    Py_DECREF(args);
    return NULL;
  }
  result = console_cmdloop((consoleobject *) console, args);
  Py_DECREF(args);
  Py_DECREF(console);
  return result;
}

static PyMethodDef module_methods[] = {
  { CONSOLE_NAME, module_console, METH_NOARGS, console_doc },
  { NULL }
};

static void import_modules(void);

#ifndef PyMODINIT_FUNC
#define PyMODINIT_FUNC DL_EXPORT(void)
#endif

PyMODINIT_FUNC MODULE_INITFUNC(void) {
  PyObject *import, *class, *item, *module;
  
  if (PyType_Ready(&Parser_Type) < 0) return;

  /* Setup the console type's base classes */
  import = PyImport_ImportModule("cmd");
  if (import == NULL) return;
  class = PyObject_GetAttrString(import, "Cmd");
  Py_DECREF(import);
  if (class == NULL) return;
  Console_Type.tp_base = &PyBaseObject_Type;
  Console_Type.tp_bases = Py_BuildValue("(ON)", class, &PyBaseObject_Type);
  if (Console_Type.tp_bases == NULL) return;
  if (PyType_Ready(&Console_Type) < 0) return;

  item = PyString_FromString(PARSER_NAME "> ");
  if (PyDict_SetItemString(Console_Type.tp_dict, "prompt", item) < 0) return;
  Py_DECREF(item);

  module = Py_InitModule(PARSER_NAME "c", module_methods);
  if (module == NULL) return;
  
  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, "new", (PyObject *) &Parser_Type);
  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, PARSER_NAME, (PyObject *) &Parser_Type);

  /* import the modules required for action routines */
  import_modules();
}

static PyObject *import_from(char *modulename, char *fromname) {
  PyObject *fromlist, *name, *module;

  fromlist = PyTuple_New(1);
  if (fromlist == NULL) return NULL;

  name = PyString_FromString(fromname);
  if (name == NULL) {
    Py_DECREF(fromlist);
    return NULL;
  }
  Py_INCREF(name);
  PyTuple_SET_ITEM(fromlist, 0, name);

  module = PyImport_ImportModuleEx(modulename, NULL, NULL, fromlist);
  Py_DECREF(fromlist);
  if (module == NULL) {
    Py_DECREF(name);
    return NULL;
  }

  fromlist = PyObject_GetAttr(module, name);
  Py_DECREF(module);
  Py_DECREF(name);
  return fromlist;
}

static void import_modules(void) {
  /* from Ft.Xml.XPath.ParsedAbsoluteLocationPath import ParsedAbsoluteLocationPath */
  ParsedAbsoluteLocationPath = import_from("Ft.Xml.XPath.ParsedAbsoluteLocationPath", "ParsedAbsoluteLocationPath");
  if (ParsedAbsoluteLocationPath == NULL) return;

  /* from Ft.Xml.XPath.ParsedRelativeLocationPath import ParsedRelativeLocationPath */
  ParsedRelativeLocationPath = import_from("Ft.Xml.XPath.ParsedRelativeLocationPath", "ParsedRelativeLocationPath");
  if (ParsedRelativeLocationPath == NULL) return;

  /* from Ft.Xml.XPath.ParsedPredicateList import ParsedPredicateList */
  ParsedPredicateList = import_from("Ft.Xml.XPath.ParsedPredicateList", "ParsedPredicateList");
  if (ParsedPredicateList == NULL) return;

  /* from Ft.Xml.XPath.ParsedStep import ParsedStep */
  ParsedStep = import_from("Ft.Xml.XPath.ParsedStep", "ParsedStep");
  if (ParsedStep == NULL) return;

  /* from Ft.Xml.XPath.ParsedStep import ParsedAbbreviatedStep */
  ParsedAbbreviatedStep = import_from("Ft.Xml.XPath.ParsedStep", "ParsedAbbreviatedStep");
  if (ParsedAbbreviatedStep == NULL) return;

  /* from Ft.Xml.XPath.ParsedAxisSpecifier import ParsedAxisSpecifier */
  ParsedAxisSpecifier = import_from("Ft.Xml.XPath.ParsedAxisSpecifier", "ParsedAxisSpecifier");
  if (ParsedAxisSpecifier == NULL) return;

  /* from Ft.Xml.XPath.ParsedNodeTest import ParsedNodeTest */
  ParsedNodeTest = import_from("Ft.Xml.XPath.ParsedNodeTest", "ParsedNodeTest");
  if (ParsedNodeTest == NULL) return;

  /* from Ft.Xml.XPath.ParsedNodeTest import ParsedNameTest */
  ParsedNameTest = import_from("Ft.Xml.XPath.ParsedNodeTest", "ParsedNameTest");
  if (ParsedNameTest == NULL) return;

  /* from Ft.Xml.XPath.ParsedNodeTest import PrincipalTypeTest */
  PrincipalTypeTest = import_from("Ft.Xml.XPath.ParsedNodeTest", "PrincipalTypeTest");
  if (PrincipalTypeTest == NULL) return;

  /* from Ft.Xml.XPath.ParsedNodeTest import LocalNameTest */
  LocalNameTest = import_from("Ft.Xml.XPath.ParsedNodeTest", "LocalNameTest");
  if (LocalNameTest == NULL) return;

  /* from Ft.Xml.XPath.ParsedAbbreviatedAbsoluteLocationPath import ParsedAbbreviatedAbsoluteLocationPath */
  ParsedAbbreviatedAbsoluteLocationPath = import_from("Ft.Xml.XPath.ParsedAbbreviatedAbsoluteLocationPath", "ParsedAbbreviatedAbsoluteLocationPath");
  if (ParsedAbbreviatedAbsoluteLocationPath == NULL) return;

  /* from Ft.Xml.XPath.ParsedAbbreviatedRelativeLocationPath import ParsedAbbreviatedRelativeLocationPath */
  ParsedAbbreviatedRelativeLocationPath = import_from("Ft.Xml.XPath.ParsedAbbreviatedRelativeLocationPath", "ParsedAbbreviatedRelativeLocationPath");
  if (ParsedAbbreviatedRelativeLocationPath == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedVariableReferenceExpr */
  ParsedVariableReferenceExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedVariableReferenceExpr");
  if (ParsedVariableReferenceExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedLiteralExpr */
  ParsedLiteralExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedLiteralExpr");
  if (ParsedLiteralExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedNLiteralExpr */
  ParsedNLiteralExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedNLiteralExpr");
  if (ParsedNLiteralExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedFunctionCallExpr */
  ParsedFunctionCallExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedFunctionCallExpr");
  if (ParsedFunctionCallExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedUnionExpr */
  ParsedUnionExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedUnionExpr");
  if (ParsedUnionExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedPathExpr */
  ParsedPathExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedPathExpr");
  if (ParsedPathExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedFilterExpr */
  ParsedFilterExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedFilterExpr");
  if (ParsedFilterExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedOrExpr */
  ParsedOrExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedOrExpr");
  if (ParsedOrExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedAndExpr */
  ParsedAndExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedAndExpr");
  if (ParsedAndExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedEqualityExpr */
  ParsedEqualityExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedEqualityExpr");
  if (ParsedEqualityExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedRelationalExpr */
  ParsedRelationalExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedRelationalExpr");
  if (ParsedRelationalExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedAdditiveExpr */
  ParsedAdditiveExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedAdditiveExpr");
  if (ParsedAdditiveExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedMultiplicativeExpr */
  ParsedMultiplicativeExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedMultiplicativeExpr");
  if (ParsedMultiplicativeExpr == NULL) return;

  /* from Ft.Xml.XPath.ParsedExpr import ParsedUnaryExpr */
  ParsedUnaryExpr = import_from("Ft.Xml.XPath.ParsedExpr", "ParsedUnaryExpr");
  if (ParsedUnaryExpr == NULL) return;

}
