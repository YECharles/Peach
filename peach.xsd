<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="http://phed.org/2008/Peach" elementFormDefault="qualified"
	xmlns="http://phed.org/2008/Peach" xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:h="http://www.w3.org/1999/xhtml">

	<!--
		
		Copyright (c) 2007-2009 Michael Eddington
		
		Permission is hereby granted, free of charge, to any person obtaining a copy 
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights 
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
		copies of the Software, and to permit persons to whom the Software is 
		furnished to do so, subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in	
		all copies or substantial portions of the Software.
		
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
		
		Authors:
		  Michael Eddington (mike@phed.org)
		
		$Id$
		
	-->

	<xs:element name="Peach">
		<xs:annotation>
			<xs:documentation>Root element of a Peach XML DDL document.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="PythonPath" />
				<xs:element ref="Import" />
				<xs:element ref="Include" />
				<xs:element ref="Defaults" />
				<xs:element ref="DataModel" />
				<xs:element ref="Data" />
				<xs:element ref="Test" />
				<xs:element ref="Run" />
				<xs:element ref="Agent" />
				<xs:element ref="StateModel" />
				<xs:element ref="Mutators"/>
				<xs:element ref="Python" />
				<xs:element ref="Analyzer" />
			</xs:choice>
			<xs:attribute name="version" type="xs:string">
				<xs:annotation>
					<xs:documentation>Version of this XML file</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="author" type="xs:string">
				<xs:annotation>
					<xs:documentation>Author of this XML file</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="description" type="xs:string">
				<xs:annotation>
					<xs:documentation>Description of this XML file</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="Python">
		<xs:annotation>
			<xs:documentation>This element allows for running Python code.  This is usefull to call any initialization methods for code
				that is later used.  This is an advanced element.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="code" type="xs:string">
				<xs:annotation>
					<xs:documentation>Python code to run.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="Defaults">
		<xs:annotation>
			<xs:documentation>This element allow setting default values for data elements.</xs:documentation>
		</xs:annotation>
	</xs:element>

	<xs:element name="DataModel" type="tTemplate">
		<xs:annotation>
			<xs:documentation>Templates are top level elements that contain other data elements. Templates
				can be based on other Templates or Blocks using the ref attribute. Templates behave much
				like Blocks. </xs:documentation>
		</xs:annotation>
		<xs:unique name="templateKey1">
			<xs:selector xpath="." />
			<xs:field xpath="@name" />
		</xs:unique>
	</xs:element>
	<xs:complexType name="tInclude">
		<xs:attribute name="ref" />
		<xs:attribute name="xpath"/>
	</xs:complexType>
	<xs:complexType name="tExclude">
		<xs:attribute name="ref" />
		<xs:attribute name="xpath"/>
	</xs:complexType>
	<xs:complexType name="tTemplate">
		<xs:annotation>
			<xs:documentation>Templates are top level elements that contain other data elements. Templates
				can be based on other Templates or Blocks using the ref attribute. Templates behave much
				like Blocks. </xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ref="Relation" minOccurs="0" maxOccurs="unbounded" />
			<xs:group ref="dataTypes" minOccurs="0" maxOccurs="unbounded" />
			<xs:element ref="Transformer" minOccurs="0" maxOccurs="1" />
			<xs:element ref="Fixup" minOccurs="0" maxOccurs="1" />
			<xs:element ref="Hint" minOccurs="0" maxOccurs="unbounded" />
			<xs:element ref="Placement" minOccurs="0" maxOccurs="1"/>
		</xs:choice>
		<xs:attributeGroup ref="peachCommonAttributes" />
		<xs:attributeGroup ref="commonTemplateAttributes" />
	</xs:complexType>
	<xs:element name="Block" type="tBlock">
		<xs:annotation>
			<xs:documentation>Blocks are combinations of other data elements combined in sequence to
				produce a block of data. A block is similar to a c structure. Blocks can contain other
				blocks, strings, numbers, etc.</xs:documentation>
		</xs:annotation>
		<xs:unique name="blockKey1">
			<xs:selector xpath="." />
			<xs:field xpath="@name" />
		</xs:unique>
	</xs:element>
	<xs:complexType name="tBlock">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ref="Block" minOccurs="0" />
			<xs:element ref="Number" minOccurs="0" />
			<xs:element ref="String" minOccurs="0" />
			<xs:element ref="Flags" minOccurs="0" />
			<xs:element ref="Blob" minOccurs="0" />
			<xs:element ref="Seek" minOccurs="0" />
			<xs:element ref="Choice" minOccurs="0" />
			<xs:element ref="Custom" minOccurs="0" />
			<xs:element ref="XmlElement" minOccurs="0" />
			<xs:element ref="XmlAttribute" minOccurs="0" />
			<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
		</xs:choice>
		<xs:attributeGroup ref="peachCommonAttributes" />
		<xs:attributeGroup ref="commonTemplateAttributes" />
		<xs:attribute name="lengthType">
			<xs:annotation>
				<xs:documentation>An optional attribute that specifies the value of length.  Default is string.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="string">
						<xs:annotation>
							<xs:documentation>Indicates the length is a number in string form, e.g. 10.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="calc">
						<xs:annotation>
							<xs:documentation>Indicates the length value is actually a python expression 
								that is evaulated to calculate the length value.  This expression will be evauluated
								every time the length value is needed.  A special variable of "self" is available in the
								expression which is the current object in the dom.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="length" type="xs:string">
			<xs:annotation>
				<xs:documentation>Specify static length of string. Default is
					unbounded.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="Number">
		<xs:annotation>
			<xs:documentation>Represents a non-ascii integer that has a size in bits, and a byte
			order.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attributeGroup ref="peachNumberAttributes" />
			<xs:attributeGroup ref="commonTemplateAttributes" />
			<xs:attributeGroup ref="ValueAttributes" />
			<xs:attribute name="isStatic" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>[Depricated, use token instead] Indicates a token in the data stream.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="token" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates a token in the data stream.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
		<xs:unique name="numberKey1">
			<xs:selector xpath="." />
			<xs:field xpath="@name" />
		</xs:unique>
	</xs:element>
	<xs:element name="Seek">
		<xs:annotation>
			<xs:documentation>Change our location in the input stream.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="relative" type="xs:int">
				<xs:annotation>
					<xs:documentation>Specify a location relative to our current one</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="position" type="xs:int">
				<xs:annotation>
					<xs:documentation>Specify a location relative to start of the input stream</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="expression" type="xs:string">
				<xs:annotation>
					<xs:documentation>A python expression to calculate the position from start of input stream</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attributeGroup ref="commonTemplateAttributes" />
		</xs:complexType>
	</xs:element>
	<xs:element name="Choice">
		<xs:annotation>
			<xs:documentation>A choice will choose zero or more of the elements it contains based on
				minOccurs and maxOccurs.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="Block" minOccurs="0" />
				<xs:element ref="Number" minOccurs="0" />
				<xs:element ref="String" minOccurs="0" />
				<xs:element ref="Flags" minOccurs="0" />
				<xs:element ref="Blob" minOccurs="0" />
				<xs:element ref="Seek" minOccurs="0" />
				<xs:element ref="Choice" minOccurs="0" />
				<xs:element ref="Custom" minOccurs="0" />
				<xs:element ref="XmlElement" minOccurs="0" />
				<xs:element ref="XmlAttribute" minOccurs="0" />
				<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attributeGroup ref="commonTemplateAttributes" />
		</xs:complexType>
		<xs:unique name="ChoiceKey1">
			<xs:selector xpath="." />
			<xs:field xpath="@name" />
		</xs:unique>
	</xs:element>
	<xs:element name="XmlElement">
		<xs:annotation>
			<xs:documentation>Represents an XML element.  XmlElement's can contain XmlAttribute children 
				and one other data element for the node value.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="Block" minOccurs="0" />
				<xs:element ref="Number" minOccurs="0" />
				<xs:element ref="String" minOccurs="0" />
				<xs:element ref="Flags" minOccurs="0" />
				<xs:element ref="Blob" minOccurs="0" />
				<xs:element ref="Seek" minOccurs="0" />
				<xs:element ref="Choice" minOccurs="0" />
				<xs:element ref="Custom" minOccurs="0" />
				<xs:element ref="XmlElement" minOccurs="0" />
				<xs:element ref="XmlAttribute" minOccurs="0" />
				<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attributeGroup ref="commonTemplateAttributes" />
			<xs:attribute name="elementName" type="xs:string">
				<xs:annotation>
					<xs:documentation>Name of the element.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ns">
				<xs:annotation>
					<xs:documentation>	XML Namespace of the element (optional)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="XmlAttribute">
		<xs:annotation>
			<xs:documentation>Represents an XML Attribute</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="Block" minOccurs="0" />
				<xs:element ref="Number" minOccurs="0" />
				<xs:element ref="String" minOccurs="0" />
				<xs:element ref="Flags" minOccurs="0" />
				<xs:element ref="Blob" minOccurs="0" />
				<xs:element ref="Seek" minOccurs="0" />
				<xs:element ref="Choice" minOccurs="0" />
				<xs:element ref="Custom" minOccurs="0" />
				<xs:element ref="XmlElement" minOccurs="0" />
				<xs:element ref="XmlAttribute" minOccurs="0" />
				<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attributeGroup ref="commonTemplateAttributes" />
			<xs:attribute name="attributeName" type="xs:string">
				<xs:annotation>
					<xs:documentation>Name of the attribute.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ns">
				<xs:annotation>
					<xs:documentation>	XML Namespace of the attribute (optional)</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="String">
		<xs:annotation>
			<xs:documentation>A string of characters. This string element can represent both char and
				wchar strings.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attribute name="type">
				<xs:annotation>
					<xs:documentation>Specify type of string. Default is char.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="char">
							<xs:annotation>
								<xs:documentation>Single byte characters</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="wchar">
							<xs:annotation>
								<xs:documentation>Double byte characters as commonly used with Windows
								applications</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="utf8">
							<xs:annotation>
								<xs:documentation>Multibyte unicode characters</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="lengthType">
				<xs:annotation>
					<xs:documentation>An optional attribute that specifies the value of length.  Default is string.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="string">
							<xs:annotation>
								<xs:documentation>Indicates the length is a number in string form, e.g. 10.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="calc">
							<xs:annotation>
								<xs:documentation>Indicates the length value is actually a python expression 
									that is evaulated to calculate the length value.  This expression will be evauluated
									every time the length value is needed.  A special variable of "self" is available in the
									expression which is the current object in the dom.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="length" type="xs:string">
				<xs:annotation>
					<xs:documentation>Specify static length of string. Default is
						unbounded.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="tokens" type="xs:string">
				<xs:annotation>
					<xs:documentation>Specify the set of tokens (as a Python array literal) that will be used to tokenize and fuzz this String. Example: &quot;[':', '.', '[' ]&quot;</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attributeGroup ref="commonTemplateAttributes" />
			<xs:attribute name="nullTerminated" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicate if string is null terminated. Default is
					false.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="isStatic" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>[Depricated, use token instead] Indicates a token in the data stream.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="token" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates a token in the data stream.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="padCharacter">
				<xs:annotation>
					<xs:documentation>Specify the character to bad the string with if it's length if less then
						specified in the length attribute. Only valid when the length attribute is also
						specified.  This field will accept python escape sequences
						such as \xNN, \r, \n, etc.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attributeGroup ref="ValueAttributes" />
		</xs:complexType>
		<xs:unique name="stringKey1">
			<xs:selector xpath="." />
			<xs:field xpath="@name" />
		</xs:unique>
	</xs:element>
	<xs:attributeGroup name="ValueAttributes">
		<xs:attribute name="valueType">
			<xs:annotation>
				<xs:documentation>Format of value attribute.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="string">
						<xs:annotation>
							<xs:documentation>Regular string. C style &quot;\&quot; escaping can be used
								such as: \r, \n, \t, and \\.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="literal">
						<xs:annotation>
							<xs:documentation>Treated as a python literal string. An example is
								&quot;[1,2,3,4]&quot; which would evauluate to a python
							list.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="hex">
						<xs:annotation>
							<xs:documentation>Hex string. Allows specifying binary data.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="value" type="xs:string">
			<xs:annotation>
				<xs:documentation>Default value of data element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:group name="dataTypes">
		<xs:choice>
			<xs:element ref="Block" minOccurs="0" />
			<xs:element ref="Number" minOccurs="0" />
			<xs:element ref="String" minOccurs="0" />
			<xs:element ref="Flags" minOccurs="0" />
			<xs:element ref="Blob" minOccurs="0" />
			<xs:element ref="Seek" minOccurs="0" />
			<xs:element ref="Choice" minOccurs="0" />
			<xs:element ref="Custom" minOccurs="0" />
			<xs:element ref="XmlElement" minOccurs="0" />
			<xs:element ref="XmlAttribute" minOccurs="0" />
		</xs:choice>
	</xs:group>
	<xs:attributeGroup name="peachCommonAttributes">
		<xs:attribute name="name" type="xs:string">
			<xs:annotation>
				<xs:documentation>Unique (to context) name for element. Names must not contain periods (.)
					or spaces ( ).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:element name="Relation">
		<xs:annotation>
			<xs:documentation>Describes relations between different data elements. Relations currently
				supported are "size" and "count".</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="type">
				<xs:annotation>
					<xs:documentation>Specify type or relation ship.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="size">
							<xs:annotation>
								<xs:documentation>A size relationship. A size relationship say be used in two ways.
									First it can say "Size of another element". When used in this manor also use the
									&quot;of&quot; attribute. Second it can say "Make me the size from another
									element". In this case use the &quot;from&quot;
								attribute.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="count">
							<xs:annotation>
								<xs:documentation>A count relationship. A count relationship can be used in two
									ways. First it can say "Count of another element that has zero or more
									occurrences". When used in this manor also use the &quot;of&quot;
									attribute. Additionally the element specified must have minOccurs and/or maxOccurs
									specified. Second it can say "Make me the count of another element." In this case
									use the &quot;from&quot; attribute. Additionally the parent element of
									this relationship must set minOccurs or maxOccurs.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="when">
							<xs:annotation>
								<xs:documentation>A when relationship says this element is only used if the expression 
									in the &quot;when&quot; attribute evaulates to true.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="offset">
							<xs:annotation>
								<xs:documentation>The position or offset from begining of data that element of is located 
									at.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="of" type="xs:string">
				<xs:annotation>
					<xs:documentation>Set size or count of this element. The parent of this relation ship will
						determine the size or count of specified element.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="from" type="xs:string">
				<xs:annotation>
					<xs:documentation>Get size or count from this element. The parent of this relationship
						will be set to the size or count of the specified element.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="when" type="xs:string">
				<xs:annotation>
					<xs:documentation>A python expression that must evauluate to true or false.  Only used
						when type is when.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="expressionGet" type="xs:string">
				<xs:annotation>
					<xs:documentation>An optional python expression that returns the value of count or length when we are
						getting the parent based on the relation.  Special 
						variables made available to the expression are: of -- the of reference, self -- The parent of this relation, 
						count -- The count from parent, length -- the length from parent.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="expressionSet" type="xs:string">
				<xs:annotation>
					<xs:documentation>An optional python expression that returns the value of count or length when we are 
						setting the parent based on the relation.  Special 
						variables made available to the expression are: of -- the of reference, self -- The parent of this relation, 
						count -- The count from of ref, length -- the length from of ref.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="relative" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Offset relation is relative to current element.  Defaults to false.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="relativeTo" type="xs:string">
				<xs:annotation>
					<xs:documentation>Offset relation is relative to specified element.  Defaults to current element.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="Flags">
		<xs:annotation>
			<xs:documentation>Define a set of bit flags. Supports multiple bit flags.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element ref="Flag" />
				<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attribute name="endian">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="little" />
						<xs:enumeration value="big" />
						<xs:enumeration value="network" />
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="size" type="xs:unsignedShort" use="required">
				<xs:annotation>
					<xs:documentation>Length in bits of this flag set. Valid values are 8, 16, 32, and
					64.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attributeGroup ref="commonTemplateAttributes" />
		</xs:complexType>
		<xs:unique name="flagsKey1">
			<xs:selector xpath="." />
			<xs:field xpath="@name" />
		</xs:unique>
	</xs:element>
	<xs:attributeGroup name="peachNumberAttributes">
		<xs:attribute name="signed" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Is number signed. Defaults to true.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="size" use="required">
			<xs:annotation>
				<xs:documentation>Size in bits of number. No default.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:unsignedShort">
					<xs:enumeration value="8" />
					<xs:enumeration value="16" />
					<xs:enumeration value="32" />
					<xs:enumeration value="24" />
					<xs:enumeration value="64" />
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="endian">
			<xs:annotation>
				<xs:documentation>Specifies the byte order of this number. Defaults to
				little.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="little" />
					<xs:enumeration value="big" />
					<xs:enumeration value="network" />
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:element name="Flag">
		<xs:annotation>
			<xs:documentation>A one or more bit flag that is part of a flag set (Flags
			element).</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attribute name="position" type="xs:unsignedShort" use="required">
				<xs:annotation>
					<xs:documentation>Position of this flag start where the first bit is zero
					(0).</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="size" type="xs:unsignedShort" use="required">
				<xs:annotation>
					<xs:documentation>Size in bits of this flag. Must be at least 1 bit, and position+size
						must be less then total length of Flag set.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attributeGroup ref="ValueAttributes" />
			<xs:attribute name="isStatic" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>[Depricated, use token instead] Indicates a token in the data stream.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="token" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates a token in the data stream.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
		<xs:unique name="flagKey1">
			<xs:selector xpath="." />
			<xs:field xpath="@name" />
		</xs:unique>
	</xs:element>
	<xs:group name="peachCommonDataElements">
		<xs:choice>
			<xs:element ref="Relation" minOccurs="0" maxOccurs="1" />
			<xs:element ref="Transformer" minOccurs="0"  maxOccurs="1"/>
			<xs:element ref="Fixup" minOccurs="0" maxOccurs="1" />
			<xs:element ref="Hint" minOccurs="0" maxOccurs="unbounded" />
			<xs:element ref="Placement" minOccurs="0" maxOccurs="1"/>
		</xs:choice>
	</xs:group>
	<xs:element name="Data">
		<xs:annotation>
			<xs:documentation>Specified a set of default data values for a template.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="Field">
					<xs:annotation>
						<xs:documentation>Specifies a value for a field in a template.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute name="name" type="xs:string">
							<xs:annotation>
								<xs:documentation>Name of field to specify a default value for. Format of name is
									&quot;Element&quot; or
								&quot;Block.Block.Element&quot;</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute name="valueType">
							<xs:annotation>
								<xs:documentation>Format of value attribute.</xs:documentation>
							</xs:annotation>
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="string">
										<xs:annotation>
											<xs:documentation>Regular string. C style &quot;\&quot; escaping can be used
												such as: \r, \n, \t, and \\.</xs:documentation>
										</xs:annotation>
									</xs:enumeration>
									<xs:enumeration value="literal">
										<xs:annotation>
											<xs:documentation>Treated as a python literal string. An example is
												&quot;[1,2,3,4]&quot; which would evauluate to a python
												list.</xs:documentation>
										</xs:annotation>
									</xs:enumeration>
									<xs:enumeration value="hex">
										<xs:annotation>
											<xs:documentation>Hex string. Allows specifying binary data.</xs:documentation>
										</xs:annotation>
									</xs:enumeration>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="value" type="xs:string">
							<xs:annotation>
								<xs:documentation>Default value for template field.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attribute name="DataModel" type="xs:string">
				<xs:annotation>
					<xs:documentation>Name of template to create defaults for. Can include a namespace
					prefix.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="ref" type="xs:string">
				<xs:annotation>
					<xs:documentation>Base this element on another element as defined by this attribute.
						Values are in "ns:parent.child.child" with the namespace optional. References are
						resolved starting at the current context and walking up through parents to the root of
						the document. In the case of a namespace prefix, resolution always starts at the
						document root (the only place namespaces are defined).</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="fileName" type="xs:string">
				<xs:annotation>
					<xs:documentation>Use contents of file to populate data model.  Peach will try and crack the file 
						based on the data model.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="expression" type="xs:string">
				<xs:annotation>
					<xs:documentation>A python expression that should return the data blob used to populate the data mode.
						Peach will try and crack the data based on the data model.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="description" type="xs:string">
				<xs:annotation>
					<xs:documentation>Optional description of data.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="Blob">
		<xs:annotation>
			<xs:documentation>A piece of binary data specified in hex.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:group ref="peachCommonDataElements" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attributeGroup ref="commonTemplateAttributes" />
			<xs:attributeGroup ref="ValueAttributes" />
			<xs:attribute name="analyzer" type="xs:string">
				<xs:annotation>
					<xs:documentation>[Optional] The class of an analyzer to further decompose data.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="isStatic" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>[Depricated, use token instead] Indicates a token in the data stream.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="token" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates a token in the data stream.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="lengthType">
				<xs:annotation>
					<xs:documentation>An optional attribute that specifies the value of length.  Default is string.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="string">
							<xs:annotation>
								<xs:documentation>Indicates the length is a number in string form, e.g. 10.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="calc">
							<xs:annotation>
								<xs:documentation>Indicates the length value is actually a python expression 
									that is evaulated to calculate the length value.  This expression will be evauluated
									every time the length value is needed.  A special variable of "self" is available in the
									expression which is the current object in the dom.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="length" type="xs:string">
				<xs:annotation>
					<xs:documentation>[Optional] Specify length of blob.  Default is unbounded.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:attributeGroup name="commonTemplateAttributes">
		<xs:attribute name="minOccurs" type="xs:string">
			<xs:annotation>
				<xs:documentation>The minimum number of times this element can occur. Setting this to zero
					(0) indicates it is optional. The default value is one (1).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="maxOccurs" type="xs:string">
			<xs:annotation>
				<xs:documentation>The maximum number of times this element can occur. The default value is
					one (1) except when minOccurs is defined in which case maxOccurs defaults to an
					arbitrarily large number to indicate a "one/zero or many" concept. maxOccurs must be
					larger or equal to minOccurs. When both minOccurs and maxOccurs are equal, that number of
					elements will always be produced.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="occurs" type="xs:int">
			<xs:annotation>
				<xs:documentation>The number of times this element can occur.  This is similar to setting both
					minOccurs and maxOccurs to the same value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ref" type="xs:string">
			<xs:annotation>
				<xs:documentation>Base this element on another element as defined by this attribute. Values
					are in "ns:parent.child.child" with the namespace optional. References are resolved
					starting at the current context and walking up through parents to the root of the
					document. In the case of a namespace prefix, resolution always starts at the document root
					(the only place namespaces are defined).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="constraint" type="xs:string">
			<xs:annotation>
				<xs:documentation>Provide a python expression that will contrain the accepted value.  Expression
					must evaulate to true or false.  The special variables 'self', and 'value' are available.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mutable" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Is data elmement mutable (able to be changed).  Setting to false will cause this field
					to not be fuzzed.  Default is true.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pointer" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Is data element wrapped in a pointer?  Default is false.  This attribute only applies when 
					ctypes based publishers are in use.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pointerDepth" type="xs:int">
			<xs:annotation>
				<xs:documentation>To what depth data element is wrapped in pointers (e.g. void** p is 2).  Defaults to 1.  This
					attribute only applies when used with the pointer attribute.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:element name="Include">
		<xs:annotation>
			<xs:documentation>Imports other Peach XML files into a namespace. This allows reusing existing
				templates from other Peach XML files.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="ns" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>The namespace prefix. One or more alphanumeric characters. Must not
						include period.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="src" type="xs:anyURI" use="required">
				<xs:annotation>
					<xs:documentation>URL of file to include. For files say
					"file:path_to_file"</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<!-- TODO Finish creating Schema for the following elements -->
	<xs:element name="PythonPath">
		<xs:annotation>
			<xs:documentation>Includes an additional path for module resolution. Synonomis with saying
				"sys.path.append()".</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="path" use="required">
				<xs:annotation>
					<xs:documentation>Include this path when resolving python modules.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="Import">
		<xs:annotation>
			<xs:documentation>Import a python file into the current context. This allows referencing
				generators and methods in external python files. Synonomis with saying "import
			xyz".</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="from">
				<xs:annotation>
					<xs:documentation>Just like the python &quot;from X import Y&quot;
					syntax.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="import" use="required">
				<xs:annotation>
					<xs:documentation>Just like the python &quot;from X import Y&quot;
					syntax.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="Mutator">
		<xs:annotation>
			<xs:documentation>Includes a Mutator in this test.  Mutators provide methods for modifying templates and states to produce fuzzing cases.
				If no Mutators are specified the default GeneratorMutator is used.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="class" use="required">
				<xs:annotation>
					<xs:documentation>Class name of the Mutator to use</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:union>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:maxLength value="1024"/>
							</xs:restriction>
						</xs:simpleType>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="string.StringMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="string.XmlW3CMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="string.PathMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="string.HostnameMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="string.FilenameMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="string.StringCaseMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="string.UnicodeBomMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="string.UnicodeStringsMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="number.NumericalEdgeCaseMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="number.NumericalVarianceMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="number.FiniteRandomNumbersMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="blob.BitFlipperMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="blob.DWORDSliderMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="datatree.DataTreeRemoveMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="datatree.DataTreeDuplicateMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="datatree.DataTreeSwapNearNodesMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								
								<xs:enumeration value="size.SizedVaranceMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="size.SizedNumericalEdgeCasesMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								
								<xs:enumeration value="array.ArrayVarianceMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="array.ArrayNumericalEdgeCasesMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="array.ArrayReverseOrderMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="array.ArrayRandomizeOrderMutator">
									<xs:annotation>
										<xs:documentation></xs:documentation>
									</xs:annotation>
								</xs:enumeration>
							</xs:restriction>
						</xs:simpleType>
					</xs:union>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="Mutators">
		<xs:annotation>
			<xs:documentation>Defines default mutators to use for testing.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice>
				<xs:element ref="Mutator" minOccurs="1" maxOccurs="unbounded"/>
			</xs:choice>
			<xs:attribute name="name" type="xs:string">
				<xs:annotation>
					<xs:documentation>Name for default mutators block.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="Test">
		<xs:annotation>
			<xs:documentation>Define a test to run. Currently a test is defined as a combination of a
				Template and optionally a Data set. In the future this will expand to include a state model,
				defaults for generation, etc.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element name="Include" type="tInclude"/>
				<xs:element name="Exclude" type="tExclude"/>
				<xs:element name="StateModel" minOccurs="0" maxOccurs="1">
					<xs:annotation>
						<xs:documentation>Reference an already declared StateMachine using the 'ref' attribute.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:choice minOccurs="0" maxOccurs="unbounded">
							<xs:element name="Path" minOccurs="1" maxOccurs="unbounded">
								<xs:complexType>
									<xs:choice minOccurs="0" maxOccurs="unbounded">
										<xs:element name="Include" type="tInclude"/>
										<xs:element name="Exclude" type="tExclude"/>
										<xs:element ref="Data"/>
										<xs:element ref="Mutator"/>
									</xs:choice>
									<xs:attribute name="ref" type="xs:string" use="required">
										<xs:annotation>
											<xs:documentation>Reference to an already declared state defined in the StateMachine</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:complexType>
							</xs:element>
							<xs:element name="Strategy" minOccurs="0" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>
										A Strategy simply explores the state machine and finds a proper route 
										passing through each Path(state) defined previous to itself. By default, if no explicit strategy
										is declared, Static strategy will be used. It just assures that Peach fuzzes directly the given Paths(states)
										(but this does not mean that it fuzzes only them! Remember to use Stop element ;)
									</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:sequence>
										<xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
									</xs:sequence>
									<xs:attribute name="class" use="required">
										<xs:annotation>
											<xs:documentation>Class name of Strategy to be used</xs:documentation>
										</xs:annotation>
										<xs:simpleType>
											<xs:union>
												<xs:simpleType>
													<xs:restriction base="xs:string">
														<xs:maxLength value="1024" />
													</xs:restriction>
												</xs:simpleType>
												<xs:simpleType>
													<xs:restriction base="xs:string">
														<xs:enumeration value="default.StaticStrategy">
															<xs:annotation>
																<xs:documentation>
																	Default(implicit) strategy for Peach. It just follows the given Path definition.	
																</xs:documentation>
															</xs:annotation>
														</xs:enumeration>
														<xs:enumeration value="random.RandomStrategy">
															<xs:annotation>
																<xs:documentation>
																	Randomly finds a route passing through the desired paths. 
																	Use numOfSteps parameter(0 to unbounded) to set up maximum number of states in between
																	start and destination paths as discovering the route.
																</xs:documentation>
															</xs:annotation>
														</xs:enumeration>
													</xs:restriction>
												</xs:simpleType>
											</xs:union>
										</xs:simpleType>
									</xs:attribute>
								</xs:complexType>
							</xs:element>
							<xs:element name="Stop" minOccurs="0" maxOccurs="1"/>
						</xs:choice>
						<xs:attribute name="ref" type="xs:string">
							<xs:annotation>
								<xs:documentation>Reference to an already declared StateMachine.  Can include a namespace prefix (e.g. 'ns:FooMachine').</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>

				<xs:element ref="Mutator" minOccurs="0" maxOccurs="unbounded"/>
				
				<xs:element name="Agent" minOccurs="0" maxOccurs="1">
					<xs:annotation>
						<xs:documentation>Reference a defined agent to use with test .</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute name="ref" type="xs:string" use="required">
							<xs:annotation>
								<xs:documentation>Reference an element to use for this test. Values are in
									"ns:parent.child.child" with the namespace being optional. Resolution always
									starts at the document root.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>

				<xs:element name="Publisher" minOccurs="1">
					<xs:annotation>
						<xs:documentation>Define the publisher to use for this test. A publisher sends and
							receives data. This can take the form of a network protocol (TCP, UDP, HTTP) or
							calling an API/DLL or COM control. For testing purposes there are publishers that will
							simply output the generated data to the console.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence minOccurs="0" maxOccurs="unbounded">
							<xs:element ref="Param" />
						</xs:sequence>
						<xs:attribute name="class" use="required">
							<xs:annotation>
								<xs:documentation>Specify the python class name of a Peach publisher class. You can
									implement your own publisher's as needed.</xs:documentation>
							</xs:annotation>
							<xs:simpleType>
								<xs:union>
									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:maxLength value="1024" />
										</xs:restriction>
									</xs:simpleType>
									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:enumeration value="tcp.Tcp">
												<xs:annotation>
													<xs:documentation>Send tests to TCP port. Requires parameters named
														&quot;host&quot; and
														&quot;port&quot;.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="tcp.TcpListener">
												<xs:annotation>
													<xs:documentation>Accepts incoming connection on a TCP port. Requires parameters named
														&quot;host&quot; and
														&quot;port&quot;.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="tcp.TcpListenerLaunchGui">
												<xs:annotation>
													<xs:documentation>Accepts incoming connection on a TCP port. Requires parameters named
														&quot;host&quot;,
														&quot;port&quot;, and &quot;windowName&quot;.  OPeration is similar to FileWriterLauncherGui.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="udp.Udp">
												<xs:annotation>
													<xs:documentation>Send tests to UDP port. Requires parameters named
														&quot;host&quot; and
													&quot;port&quot;.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="process.Command">
												<xs:annotation>
													<xs:documentation>Run a command and pass generated data as first parameter.  Requires a 
														parameter named &quot;command&quot;.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="stdout.Stdout">
												<xs:annotation>
													<xs:documentation>Print tests to console. No
													parameters.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="stdout.StdoutHex">
												<xs:annotation>
													<xs:documentation>Print tests to console in hex and ASCII format. No
													parameters.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>											
											<xs:enumeration value="file.FileWriter">
												<xs:annotation>
													<xs:documentation>Writes tests to a file. Requires parameter named
														&quot;filename&quot;.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="file.FileReader">
												<xs:annotation>
													<xs:documentation>Readers data from a file. Requires parameter named
														&quot;filename&quot;.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="file.FilePerIteration">
												<xs:annotation>
													<xs:documentation>Writes tests to a series of files. Requires parameter
														named &quot;filename&quot;. The value of this parameter must be
														in format &quot;c:\path\file%d.ext&quot; where %d will become
														the test count #.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="file.FileWriterLauncher">
												<xs:annotation>
													<xs:documentation>Writes a file and then allows launching an application
														using the call action with method the program to launch.  Requires a single
														parameter, the name of the file to create.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="file.FileWriterLauncherGui">
												<xs:annotation>
													<xs:documentation>Writes a file and then allows launching an application
														using the call action with method the program to launch.  Two parameters
														are required.  First is the filename to create and the second is a partial or
														full window title of the launched application.  A WM_CLOSE meesage will be
														sent to the app to try and close it.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="sql.Odbc">
												<xs:annotation>
													<xs:documentation>Will execute test cases as SQL queries. Requires
														parameter named &quot;dsn&quot; that is a valid ODBC
														DSN.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="com.Com">
												<xs:annotation>
													<xs:documentation>A simple COM publisher that will pass a test case as a
														parameter to a single method call. Requires a parameters named
														&quot;clsid&quot; and &quot;methodFormat&quot;. The
														methodFormat parameter is in format:
														FunctionName(&quot;%s&quot;) where %s will be replaced with the
														test case.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="Publisher">
												<xs:annotation>
													<xs:documentation>A do nothing publisher. Used when XML will be consumed
														by another program such as PeachTcpServer.py which does not make use of
														a standard publisher.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
										</xs:restriction>
									</xs:simpleType>
								</xs:union>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:attribute name="name" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>Name of test case</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="description" type="xs:string">
				<xs:annotation>
					<xs:documentation>Optional description of data.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="Param">
		<xs:annotation>
			<xs:documentation>Param elements provide parameters for the parent element. It is possible to
				pass python types like arrays by specifying valueType as literal and providing python
				literal as value. e.g. &quot;[ 1, 2, 3, 4 ]&quot; would be an
			array.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="name" use="required">
				<xs:annotation>
					<xs:documentation>Parameter name.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="valueType">
				<xs:annotation>
					<xs:documentation>Format of value attribute.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="string">
							<xs:annotation>
								<xs:documentation>Regular string. C style &quot;\&quot; escaping can be used
									such as: \r, \n, \t, and \\.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="literal">
							<xs:annotation>
								<xs:documentation>Treated as a python literal string. An example is
									&quot;[1,2,3,4]&quot; which would evauluate to a python
								list.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="hex">
							<xs:annotation>
								<xs:documentation>Hex string. Allows specifying binary data.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="ref">
							<xs:annotation>
								<xs:documentation>Only valid for Param elements that are children of Generator elements.
									Specify the name of another element here and that elements Generator will get passed
									in as this argument.  Usefull when building a Generator to provide a custom checksum
									type field.  See IcmpChecksum and BlockSize as examples.  GeneratorReference.xml is
									and example XML that uses this feature.</xs:documentation>
							</xs:annotation>
						</xs:enumeration>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="value" use="required">
				<xs:annotation>
					<xs:documentation>Value of parameter.  By default value attribute is a python string literal.  This means &quot;\n&quot; 
						and &quot;\r&quot; will evaluate as in Python.  This also means backslashes (\) need to be escaped.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="Run">
		<xs:annotation>
			<xs:documentation>A collection of tests to run at once. The run name
				&quot;DefaultRun&quot; is special and will be run if no other run name is
				provided.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="1" maxOccurs="unbounded">
				<xs:element name="Logger" minOccurs="0" maxOccurs="1">
					<xs:annotation>
						<xs:documentation>Specify a a logging mechanism for fuzzing Run.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
						</xs:sequence>
						<xs:attribute name="class" use="required">
							<xs:annotation>
								<xs:documentation>Specify the python class name of a Peach Logger class. You can
									implement your own loggers as needed.</xs:documentation>
							</xs:annotation>
							<xs:simpleType>
								<xs:union>
									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:maxLength value="1024" />
										</xs:restriction>
									</xs:simpleType>
									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:enumeration value="logger.Filesystem">
												<xs:annotation>
													<xs:documentation>Log to a path on the file system.  Requires a 
														single parameter named "path" with the fully qualified path 
														place logged information.  This will include any data reported
														by Agents and Monitors along with a text file containing
														the sent and received data for each logged test.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<!--								<xs:enumeration value="logger.SQL">
												<xs:annotation>
												<xs:documentation>Log to a SQL server (MySQL).  Requires a 
												single parameter named "path" with the fully qualified path 
												place logged information.  This will include any data reported
												by Agents and Monitors along with a text file containing
												the sent and received data for each logged test.</xs:documentation>
												</xs:annotation>
												</xs:enumeration> -->
										</xs:restriction>
									</xs:simpleType>
								</xs:union>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute name="faultsOnly" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>Should we only log faults or all tests performed?  Defaults to true.  
									Note: Setting this to false will cause large amounts of data to be logged and is 
									not recommended.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<xs:element name="Test" minOccurs="1" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Includes a previosly defined test in this run.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute name="ref" type="xs:string" use="required">
							<xs:annotation>
								<xs:documentation>Reference a test to use for in this run. Values are in
									"ns:parent.child.child" with the namespace being optional. Resolution always
									starts at the document root.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:attribute name="name" type="xs:string">
				<xs:annotation>
					<xs:documentation>Name of run. May not contian spaces or periods (.).</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="waitTime" type="xs:decimal">
				<xs:annotation>
					<xs:documentation>Time to wait in seconds between each test case. Value can be fractional
						(0.25). Defaults to zero (0).</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="description" type="xs:string">
				<xs:annotation>
					<xs:documentation>Optional description of run.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="Hint">
		<xs:annotation>
			<xs:documentation>Hints provide additional information about data elements that are used by 
				mutators to better target the elements value.  Examples of hints might be indicating the type
				is really XML.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="name">
				<xs:annotation>
					<xs:documentation>Name of Hint</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:union>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:maxLength value="1024"/>
							</xs:restriction>
						</xs:simpleType>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="type">
									<xs:annotation>
										<xs:documentation>Provide a hint about content type.  Examples of values are: 
											xml, filename, path, unc, url, ipv4addr, ipv6addr, hostname, domainname, 
											etc.  See mutators for list of hints they operate on.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="related">
									<xs:annotation>
										<xs:documentation>Provide a hint about related data elements.  Value is a 
											comma separated list of other elements.  Values that are seen as related could
											be fuzzed together.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
							</xs:restriction>
						</xs:simpleType>
					</xs:union>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="value">
				<xs:annotation>
					<xs:documentation>Value of hint.  Examples: xml, filename, path, unc, url, etc.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="Transformer">
		<xs:annotation>
			<xs:documentation>Transform data into another format. This can include encoding it in some way
				(base64), compressing it (gzip), etc.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0">
				<xs:element ref="Param" />
				<xs:element ref="Transformer" minOccurs="0" maxOccurs="1" />
			</xs:choice>
			<xs:attribute name="class">
				<xs:annotation>
					<xs:documentation>Specify the python class name of a Peach transformer class. You can
						implement your own transformers's as needed.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:union>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:maxLength value="1024" />
							</xs:restriction>
						</xs:simpleType>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="asn1.DerEncodeOctetString">
									<xs:annotation>
										<xs:documentation>DER encode a string ASN.1 style</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="asn1.DerEncodeInteger">
									<xs:annotation>
										<xs:documentation>DER encode an integer ASN.1 style</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="asn1.BerEncodeOctetString">
									<xs:annotation>
										<xs:documentation>BER encode a string ASN.1 style</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="asn1.BerEncodeInteger">
									<xs:annotation>
										<xs:documentation>BER encode an integer ASN.1 style</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="asn1.CerEncodeOctetString">
									<xs:annotation>
										<xs:documentation>CER encode a string ASN.1 style</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="asn1.CerEncodeInteger">
									<xs:annotation>
										<xs:documentation>CER encode an integer ASN.1 style</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="compress.GzipCompress">
									<xs:annotation>
										<xs:documentation>Gzip compression</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="compress.GzipDecompress">
									<xs:annotation>
										<xs:documentation>Gzip decompression </xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="compress.Bz2Compress">
									<xs:annotation>
										<xs:documentation>bzip2 compression</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="compress.Bz2Decompress">
									<xs:annotation>
										<xs:documentation>bzip2 decompression </xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="crypto.Crypt">
									<xs:annotation>
										<xs:documentation>UNIX style crypt. Optional parameter with name of
											&quot;salt&quot; can be used to specify the crypt salt
											value.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="crypto.UnixMd5Crypt">
									<xs:annotation>
										<xs:documentation>UNIX style MD5 crypt. Optional parameters with names of
											&quot;salt&quot; and &quot;magic&quot; can be
											specified.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="crypto.ApacheMd5Crypt">
									<xs:annotation>
										<xs:documentation>Apache style MD5 crypt. Optional parameter with name of
											&quot;salt&quot; can be specified.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="crypto.CvsScramble">
									<xs:annotation>
										<xs:documentation>CVS pserver password scramble</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="crypto.Md5">
									<xs:annotation>
										<xs:documentation>MD5 transform (binary)</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="crypto.Sha1">
									<xs:annotation>
										<xs:documentation>SHA-1 transform (binary)</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="crypto.Hmac">
									<xs:annotation>
										<xs:documentation>HMAC as described in RFC 2104. A required parameter of name
											&quot;key&quot; is needed. Additionally an optional paramter of
											&quot;digestmod&quot; can be specified with a value of md5 or
											sha.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.SidStringToBytes">
									<xs:annotation>
										<xs:documentation>Convert a string representation SID to a byte
											form.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.WideChar">
									<xs:annotation>
										<xs:documentation>Make a normal string a wchar string</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.UrlEncode">
									<xs:annotation>
										<xs:documentation>URL encode w/o pluses.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.NetBiosDecode">
									<xs:annotation>
										<xs:documentation>NetBiosName Decode</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.NetBiosEncode">
									<xs:annotation>
										<xs:documentation>NetBiosName Encoded</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.UrlEncodePlus">
									<xs:annotation>
										<xs:documentation>URL encode with spaces turned to pluses</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Base64Encode">
									<xs:annotation>
										<xs:documentation>Base64 encode.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Base64Decode">
									<xs:annotation>
										<xs:documentation>Base64 decode.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.HtmlEncodeAgressive">
									<xs:annotation>
										<xs:documentation>Perform agressive HTML encoding.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.HtmlEncode">
									<xs:annotation>
										<xs:documentation>Perform standard HTML encoding of &gt; &lt; &amp;
											and &quot;</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.HtmlDecode">
									<xs:annotation>
										<xs:documentation>Decode HTML encoded string</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Utf16">
									<xs:annotation>
										<xs:documentation>Encode string as UTF-16.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Utf16Le">
									<xs:annotation>
										<xs:documentation>Encode string as UTF-16LE.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Utf16Be">
									<xs:annotation>
										<xs:documentation>Encode string as UTF-16BE.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Ipv4StringToOctet">
									<xs:annotation>
										<xs:documentation>Convert a dot notiation ipv4 address into a 4 byte octect
											representation.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Ipv4StringToNetworkOctet">
									<xs:annotation>
										<xs:documentation>Convert a dot notiation ipv4 address into a 4 byte octect
											representation.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Ipv6StringToOctet">
									<xs:annotation>
										<xs:documentation>Convert a collen notiation ipv6 address into a 4 byte octect
											representation.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.Hex">
									<xs:annotation>
										<xs:documentation>Transforms a number into a hex string (10 becomes A).</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="encode.HexString">
									<xs:annotation>
										<xs:documentation>Transforms a string of bytes into the specified Hex
											format.  Example: "22"  becomes "32 32", "A" becomes "42".</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.NumberToString">
									<xs:annotation>
										<xs:documentation>Transforms any type of number (int, long, float) to
											string.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.StringToInt">
									<xs:annotation>
										<xs:documentation>Transform a string into an integer (atoi).</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.StringToFloat">
									<xs:annotation>
										<xs:documentation>Transform a string into an float (atof).</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.IntToHex">
									<xs:annotation>
										<xs:documentation>Transform an integer into hex.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.AsInt8">
									<xs:annotation>
										<xs:documentation>Transform an number to an INT8 or UINT8. Two optional
											parameters can be specified of &quot;isSigned&quot; and
											&quot;isLittleEndian&quot;. Both default to true.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.AsInt16">
									<xs:annotation>
										<xs:documentation>Transform an number to an INT16 or UINT16. Two optional
											parameters can be specified of &quot;isSigned&quot; and
											&quot;isLittleEndian&quot;. Both default to true.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.AsInt24">
									<xs:annotation>
										<xs:documentation>Transform an number to a UINT24 (don't ask). One optional
											parameter can be specified of &quot;isLittleEndian&quot;. Defaults to
											true.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.AsInt32">
									<xs:annotation>
										<xs:documentation>Transform an number to an INT32 or UINT32. Two optional
											parameters can be specified of &quot;isSigned&quot; and
											&quot;isLittleEndian&quot;. Both default to true.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="type.AsInt64">
									<xs:annotation>
										<xs:documentation>Transform an number to an INT64 or UINT64. Two optional
											parameters can be specified of &quot;isSigned&quot; and
											&quot;isLittleEndian&quot;. Both default to true.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
							</xs:restriction>
						</xs:simpleType>
					</xs:union>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="Fixup">
		<xs:annotation>
			<xs:documentation>Transform data into another format. This can include encoding it in some way
				(base64), compressing it (gzip), etc.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
			</xs:choice>
			<xs:attribute name="class">
				<xs:annotation>
					<xs:documentation>Specify the python class name of a Peach Fixup class. You can
						implement your own fixups as needed.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:union>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:maxLength value="1024" />
							</xs:restriction>
						</xs:simpleType>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="checksums.MD5Fixup">
									<xs:annotation>
										<xs:documentation>Standard MD5</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.SHA1Fixup">
									<xs:annotation>
										<xs:documentation>Standard SHA1</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.SHA224Fixup">
									<xs:annotation>
										<xs:documentation>Standard SHA224</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.SHA256Fixup">
									<xs:annotation>
										<xs:documentation>Standard SHA256</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.SHA384Fixup">
									<xs:annotation>
										<xs:documentation>Standard SHA384</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.SHA512Fixup">
									<xs:annotation>
										<xs:documentation>Standard SHA512</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.Crc32Fixup">
									<xs:annotation>
										<xs:documentation>Standard CRC32 as defined in ISO 3309.  Used by PNG, ZIP, etc.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.Crc32DualFixup">
									<xs:annotation>
										<xs:documentation>Standard CRC32 as defined in ISO 3309.  This version takes 
											two ref arguments and will calculate the first CRC32 and then add the 2nd.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.EthernetChecksumFixup">
									<xs:annotation>
										<xs:documentation>Ethernet Checksum</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="checksums.IcmpChecksumFixup">
									<xs:annotation>
										<xs:documentation>ICMP Checksum</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="sequence.SequenceIncrementFixup">
									<xs:annotation>
										<xs:documentation>Allows a field to emit a sequential value without adding additional test cases. This is useful for sequence numbers common in network protocols. 
										</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
								<xs:enumeration value="sequence.SequenceRandomFixup">
									<xs:annotation>
										<xs:documentation>Allows a field to emit a random value without adding additional test cases. This is useful for sequence numbers common in network protocols. 
										</xs:documentation>
									</xs:annotation>
								</xs:enumeration>							
							</xs:restriction>
						</xs:simpleType>
					</xs:union>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="Custom">
		<xs:annotation>
			<xs:documentation>A custom data type for use in data models.  Requires custom python
				code that implements parsing, cracking, and generation of data.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:any />
			</xs:choice>
			
			<xs:attributeGroup ref="peachCommonAttributes" />
			<xs:attributeGroup ref="commonTemplateAttributes" />
			<xs:attribute name="class">
				<xs:annotation>
					<xs:documentation>Specify the python class name of a Peach Custom class. You can
						implement your own custom types as needed.</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:maxLength value="1024" />
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="Placement">
		<xs:annotation>
			<xs:documentation>Indicate to the data cracker (parser) were this node should live after data is parsed into it.
				the only use for this element is when dealing with files that contain offset changes that must be parsed via
				a Data element or input/getprop state action.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="after" type="xs:string">
				<xs:annotation>
					<xs:documentation>Specifies the element that this element should occur after.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="before" type="xs:string">
				<xs:annotation>
					<xs:documentation>Indicates this element should occur before the specified element.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="Analyzer">
		<xs:annotation>
			<xs:documentation>Call an analyzer to build out part of the DOM.  Parameters are passed using Param element.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
			</xs:sequence>
			<xs:attribute name="class" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>Full class name of the Analyzer to use.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	
	<xs:element name="StateModel">
		<xs:annotation>
			<xs:documentation>Defines a state machine to use during a fuzzing test.  State machines in Peach are intended to be
				fairly simple and allow for only the basic modeling typically required for fuzzing state aware protocols or 
				call sequences.  State machines are made up of one or more States which are inthem selves make up of
				one or more Action.  As Actions are executed the data can be moved between them as needed.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="State" minOccurs="1" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>The State element defines a sequence of Actions to perform.  Actions can cause a 
							change to another State.  Such changes can occur dynamically based on content received or sent
							by attaching python expressions to actions via the onStart/onComplete/when attributes.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:choice minOccurs="0" maxOccurs="unbounded">
							<xs:element name="Action" minOccurs="1" maxOccurs="unbounded">
								<xs:annotation>
									<xs:documentation>Defines an action to perform in this state.  Actions are things such as send 
										output, receive input, or change state.  Actions are performed top down.</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:choice minOccurs="0" maxOccurs="unbounded">
										<xs:element name="DataModel" maxOccurs="1">
											<xs:complexType>
												<xs:attribute name="name" type="xs:string"/>
												<xs:attribute name="ref" type="xs:string">
													<xs:annotation>
														<xs:documentation>Reference an element to use for this test. Values are in
															"ns:parent.child.child" with the namespace being optional. Resolution always
															starts at the document root.</xs:documentation>
													</xs:annotation>
												</xs:attribute>
											</xs:complexType>
										</xs:element>
										<xs:element ref="Data" maxOccurs="1" minOccurs="0" />
										<xs:element name="Param" minOccurs="0" maxOccurs="unbounded">
											<xs:annotation>
												<xs:documentation>Define a parameter for call.  Parameters are passed in the order they appear.</xs:documentation>
											</xs:annotation>
											<xs:complexType>
												<xs:choice minOccurs="1" maxOccurs="unbounded">
													<xs:element name="DataModel" maxOccurs="1" minOccurs="1">
														<xs:complexType>
															<xs:attribute name="ref" type="xs:string">
																<xs:annotation>
																	<xs:documentation>Reference a Template element to use for this test. Values are in
																		"ns:parent.child.child" with the namespace being optional. Resolution always
																		starts at the document root.</xs:documentation>
																</xs:annotation>
															</xs:attribute>
														</xs:complexType>
													</xs:element>
													<xs:element ref="Data" maxOccurs="1" minOccurs="0" />
												</xs:choice>
												<xs:attribute name="name" type="xs:string">
													<xs:annotation>
														<xs:documentation>Name of this Action</xs:documentation>
													</xs:annotation>
												</xs:attribute>
												<xs:attribute name="type">
													<xs:annotation>
														<xs:documentation>The type of action this is.</xs:documentation>
													</xs:annotation>
													<xs:simpleType>
														<xs:restriction base="xs:string">
															<xs:enumeration value="in">
																<xs:annotation>
																	<xs:documentation>In parameter</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="out">
																<xs:annotation>
																	<xs:documentation>Out parameter</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="inout">
																<xs:annotation>
																	<xs:documentation>In and Out parameter</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
														</xs:restriction>
													</xs:simpleType>
												</xs:attribute>
												
											</xs:complexType>
										</xs:element>
										<xs:element name="Result" minOccurs="0" maxOccurs="1">
											<xs:annotation>
												<xs:documentation>Used to capture return value of call.</xs:documentation>
											</xs:annotation>
											<xs:complexType>
												<xs:choice minOccurs="1" maxOccurs="unbounded">
													<xs:element name="DataModel" maxOccurs="1" minOccurs="1">
														<xs:complexType>
															<xs:attribute name="ref" type="xs:string">
																<xs:annotation>
																	<xs:documentation>Reference a Template element to use for this test. Values are in
																		"ns:parent.child.child" with the namespace being optional. Resolution always
																		starts at the document root.</xs:documentation>
																</xs:annotation>
															</xs:attribute>
														</xs:complexType>
													</xs:element>
												</xs:choice>
												<xs:attribute name="name" type="xs:string">
													<xs:annotation>
														<xs:documentation>Name of this Action</xs:documentation>
													</xs:annotation>
												</xs:attribute>												
											</xs:complexType>
										</xs:element>
									</xs:choice>
									<!-- Attributes for Action -->
									<xs:attribute name="name" type="xs:string">
										<xs:annotation>
											<xs:documentation>Name of this Action</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="ref" type="xs:string">
										<xs:annotation>
											<xs:documentation>Reference to another State.  Only used when type is changeState.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="method" type="xs:string">
										<xs:annotation>
											<xs:documentation>Metod to invoke.  Only used when type is call.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="property" type="xs:string">
										<xs:annotation>
											<xs:documentation>Property to invoke.  Only used when type is setprop or getprop.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="setXpath" type="xs:string">
										<xs:annotation>
											<xs:documentation>xpath expression that will return one or more nodes to modify defaultValue of.  Only used when type is xpath.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="valueXpath" type="xs:string">
										<xs:annotation>
											<xs:documentation>xpath expression that finds a single node to get a value from.  Only used when type is xpath.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="value" type="xs:string">
										<xs:annotation>
											<xs:documentation>value to set on setXpath nodes.  Only used when type is xpath.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="when" type="xs:string">
										<xs:annotation>
											<xs:documentation>Python expression that will be evauluated before this Action is performed.  If the 
												expression evaulates to true the action will be performed otherwise it will be skipped.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="onStart" type="xs:string">
										<xs:annotation>
											<xs:documentation>A python expression that will be evaulated at the start of this Action being performed.  It is
												evauluated after the when expression (if present) is evauluated.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="onComplete" type="xs:string">
										<xs:annotation>
											<xs:documentation>A python expression that will be evaulated after the Action has been performed.</xs:documentation>
										</xs:annotation>
									</xs:attribute>
									<xs:attribute name="type">
										<xs:annotation>
											<xs:documentation>The type of action this is.</xs:documentation>
										</xs:annotation>
										<xs:simpleType>
											<xs:restriction base="xs:string">
												<xs:enumeration value="input">
													<xs:annotation>
														<xs:documentation>Receive data</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="output">
													<xs:annotation>
														<xs:documentation>Send data</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="changeState">
													<xs:annotation>
														<xs:documentation>Change to another state specified by the ref attribute.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="call">
													<xs:annotation>
														<xs:documentation>Perform a call using specified parameters.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="getprop">
													<xs:annotation>
														<xs:documentation>Get value from property.  Not all publishers support this (COM does).  Requires a Result child element.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="setprop">
													<xs:annotation>
														<xs:documentation>Set value for property.  Not all publishers support this (COM does). Requires a single Param of type in.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="slurp">
													<xs:annotation>
														<xs:documentation>Evaulate an xpath expression against an XML DOM of the State Machine object model.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="start">
													<xs:annotation>
														<xs:documentation>Start a publisher.  Must be first action for a publisher.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="stop">
													<xs:annotation>
														<xs:documentation>Stop a publisher.  Must be last action for a publisher.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="connect">
													<xs:annotation>
														<xs:documentation>Cause publisher to make a connection (if supported).  This is also synonomis with open.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="open">
													<xs:annotation>
														<xs:documentation>Cause publisher to perform an open operation (if supported).  This is also synonomis with connect.</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="accept">
													<xs:annotation>
														<xs:documentation>Cause publisher to accept an incoming connection (if supported).</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
												<xs:enumeration value="close">
													<xs:annotation>
														<xs:documentation>Cause publisher to close a connection (outgoing or incoming if supported).</xs:documentation>
													</xs:annotation>
												</xs:enumeration>
											</xs:restriction>
										</xs:simpleType>
									</xs:attribute>
								</xs:complexType>
							</xs:element>
							<xs:element name="Choice" minOccurs="0">
								<xs:complexType>
									<xs:choice maxOccurs="unbounded">
										<xs:element name="Action" minOccurs="1" maxOccurs="unbounded">
											<xs:complexType>
												<xs:attribute name="ref" type="xs:string" use="required"/>
												<xs:attribute name="type" use="required">
													<xs:simpleType>
														<xs:restriction base="xs:string">
															<xs:enumeration value="changeState"/>
														</xs:restriction>
													</xs:simpleType>
												</xs:attribute>
											</xs:complexType>
										</xs:element>
									</xs:choice>
								</xs:complexType>
							</xs:element>
						</xs:choice>
						<!-- Attributes for State -->
						<xs:attribute name="name" type="xs:string">
							<xs:annotation>
								<xs:documentation>Name of state</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute name="onEnter" type="xs:string">
							<xs:annotation>
								<xs:documentation>A python expression that is evauluated on the start of this states execution.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute name="onExit" type="xs:string">
							<xs:annotation>
								<xs:documentation>A python expression that is evauluated on the end of this states execution.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<!-- Attributes for StateMachine -->
			<xs:attribute name="name" type="xs:string">
				<xs:annotation>
					<xs:documentation>Name of state machine</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="initialState" type="xs:string">
				<xs:annotation>
					<xs:documentation>Name of the state to execute first.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>

	<xs:element name="Agent">
		<xs:annotation>
			<xs:documentation>Configure a local or remote agent. Agents can perform variouse tasks during
				a fuzzing run. This element must include at least one Monitor child.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element ref="PythonPath" />
				<xs:element ref="Import" />
				
				<xs:element name="Monitor" minOccurs="1" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation>Monitors are agent modules that can perform a number of tasts such as
							monitoring a target application to detect faults, restarting virtual machines,
							recording network traffice, etc. Custom monitors can easily be created and used along
							with the included monitors.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
						</xs:sequence>
						<xs:attribute name="name" type="xs:string" >
							<xs:annotation>
								<xs:documentation>Name of monitor.  Will be used when logging monitor information.  Default is GUID.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute name="class" use="required">
							<xs:annotation>
								<xs:documentation>Specify the python class name of a Peach Monitor class. You can
									implement your own monitors as needed.</xs:documentation>
							</xs:annotation>
							<xs:simpleType>
								<xs:union>
									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:maxLength value="1024" />
										</xs:restriction>
									</xs:simpleType>
									<xs:simpleType>
										<xs:restriction base="xs:string">
											<!-- <xs:enumeration value="debugger.WindowsAppVerifier">
												<xs:annotation>
													<xs:documentation> Uses Microsoft AppVerifier tool to detect faults
														on running processes. AppVerifier can be downloaded from Microsoft.
														The following paramter is required: Application.  NOTE: This monitor
														does not start the child process.  Use process.Process for that.</xs:documentation>
												</xs:annotation>
											</xs:enumeration> -->
											<xs:enumeration value="debugger.WindowsDebugEngine">
												<xs:annotation>
													<xs:documentation>Windows WinDbg agent. This debugger agent is based on
														the windbg engine and supports the following features: User mode
														debugging, Kernel mode debugging, x86 and x64, Symbols and symbol
														server.   To use WinDBG *must* be installed.  One of the following three 
														parameters are required: CommandLine, ProcessName, or KernelConnectionString.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="gui.PopupWatcher">
												<xs:annotation>
													<xs:documentation>Monitors for windows that contain a specific string.  Multiple
														copies of this monitor can run at once.  When a window with the specified string
														pops-up it can be closed, or trigger a fault.  Valid paramters are as follows:
														CloseWindows (bool) indicate if Window should be closed; TriggerFaults (bool)
														indicate if Window should trigger a fault; WindowNames (comma separated string)
														a list of Window names to look for.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="vm.Vmware">
												<xs:annotation>
													<xs:documentation>Control a vmware server instance to start/revert the
														target vm. Two parameters are required of &quot;host&quot; and
														&quot;vmx&quot;. The host parameter specifies the hostname or ip
														address of the vmware server. The vmx parameter gives the location of
														the .vmx file of the VM to use.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="process.PageHeap">
												<xs:annotation>
													<xs:documentation>
														Enables PageHeap for an executable on the start of a test and then 
														disables it after the test has run.  A required parameter of &quot;Executable&quot;
														is required.  This is filename NOT including path (notepad.exe).  An
														optional parameter of &quot;Path&quot; can be supplied to provide
														the path for the Microsoft Debugging Tools for Windows (windbg).
														If not specified the default install location on the C parition is used.
													</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="process.Process">
												<xs:annotation>
													<xs:documentation>Process control agent. This agent is able to start,
														stop, and monitor if a process is running. If the process exits early a
														fault will be issued to the fuzzer. Requires a parameter of
														&quot;Command&quot; that specifies the full command line to be
														run. Optional boolean parameters of
														&quot;RestartOnEachTest&quot; (defaults to false) and
														&quot;FaultOnEarlyExit&quot; (defaults to true) can also be
														specified.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<!--
											<xs:enumeration value="popupkiller.PopupKiller">
												<xs:annotation>
													<xs:documentation>TODO - Will click through specified dialog
													boxes.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											-->
											<xs:enumeration value="network.PcapMonitor">
												<xs:annotation>
													<xs:documentation>Monitor and capture network traffic using PCAP library.
														Capture is restart for each test. In event of a fault the capture file
														is kept for further analysis.</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="socketmon.SocketMonitor">
												<xs:annotation>
													<xs:documentation>Monitors a given socket for connections. Issues a fault 
														when a connection is made to the specified socket.
														Capture is restart for each test. OnFault it will return the IP and
														port of the connecting client. Accepts three parameters: &quot;IP&quot;,
														&quot;Port&quot;, and &quot;Protocol&quot;. IP defaults to &quot;127.0.0.1&quot;,
														Port defaults to &quot;8002&quot;, and Protocol defaults to &quot;tcp&quot;.
													</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
											<xs:enumeration value="memory.Memory">
												<xs:annotation>
													<xs:documentation>Monitors the memory consumption of a given process.
														Accepts the following parameters: StopOnFault, MemoryLimit, Pid, and
														ProcessName. MemoryLimit and either Pid or ProcessName are required.
														If set, StopOnFault must be set to &quot;True&quot; or &quot;False&quot;.
														MemoryLimit is specified in bytes. Specify ProcessName without the file
														extension. i.e &quot;calc.exe&quot; becomes &quot;calc&quot;
													</xs:documentation>
												</xs:annotation>
											</xs:enumeration>


										</xs:restriction>
									</xs:simpleType>
								</xs:union>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:attribute name="name" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>Name of agent. May not contian spaces or periods (.).</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="password" type="xs:string">
				<xs:annotation>
					<xs:documentation>Password to the remote agent if needed.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="location">
				<xs:annotation>
					<xs:documentation>Specify location of agent. Value is &quot;LocalAgent&quot; or the
						hostname/ipaddress of the agent (defaults to LocalAgent)</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:union>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:maxLength value="1024" />
							</xs:restriction>
						</xs:simpleType>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="local">
									<xs:annotation>
										<xs:documentation>Special location type that will cause the Peach Engine to
											automatically create an agent running locally.</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
							</xs:restriction>
						</xs:simpleType>
					</xs:union>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>	
</xs:schema>

<!-- END -->
